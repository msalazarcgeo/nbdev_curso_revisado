[
  {
    "objectID": "contenido/Contenido/Tema2/Instalacion_rapida.html",
    "href": "contenido/Contenido/Tema2/Instalacion_rapida.html",
    "title": "Curso Nbdev Introducción",
    "section": "",
    "text": "Para hacer uso de nbdev es necesario los siguientes softwares:\n\nPython (Python o conda)\nJupyter Notebooks\nQuarto\nGithub\nnbdev\n\nA continuación se da una breve explicación de cada uno de estos y como lo utilizamos.\n\n\nAnaconda es una empresa la cual desarrolló un manejador de ambientes virtuales con un manejador de paquetes (conda), éste nos permite la creación de ambientes virtuales. Dentro de dichos ambientes se puede hacer un manejo eficiente de los diferentes softwares instalados dentro del ambiente virtual y las dependencias de los mismos. Al tener un manejo eficiente de las paqueterias y las dependencias dentro de este se hace más fácil la creación de ambientes de desarrollo.\nDe esta forma algo instalado dentro de un ambiente virtual no afectará a las distintas paqueterías que se encuentran fuera del ambiente virtual. Lo cual nos permite tener tener aislado un ambiente de desarrollo con respecto al sistema operativo u otro ambiente de desarrollo.\n\n\nPara la instalación de conda lo más sencillo es seguir el este manual aquí sólo se hace un esbozo de la instalación.\n\nBajar el instalador:\n\nAnaconda para windows.\n\nVerificar que se ha bajano correctamente (ver ).\nHacer doble click en el archivo .exe (similar a Anaconda3-######-Windows-x86_64.exe). Para la instalación en Linux o Mac se debe de bajar el archivo Anaconda3-####-Linux-###.sh o bien el Anaconda3-####-MACOSX-###.sh y ejecutar el archivo usando la terminal.\nSeguir las instrucciones en la pantalla en caso de windows. Y seguir las instrucciones que aparecerán en caso del uso de la terminal.\nPara probar la instalación abra la terminal de windows (cmd) o el anaconda prompt y corra el comando conda list. Una lista de paquetes aparecerá si se instaló de forma correcta.\n\n\n\n\nPara generar un ambiente virtual usando anaconda se puede hacer a través de la terminal. En caso de windows se puede hacer llamando a Anaconda Prompt.\nDentro de la terminal se puede observar que antes del símbolo del sistema aparece la leyenda (base) esta no indica que estamos usando el ambiente virtual base.\nPara crear un nuevo ambiente virtual se ejecuta la siguiente linea en la linea de comandos.\nconda create -n desarrollo\nEste comando crea un nuevo ambiente virtual llamado desarrollo. Se puede especificar la versión de python a instalar dentro del ambiente virtual. También es posible instalar otros lenguajes de programación dentro del ambiente virtual como son R o Julia.\nPara entrar al ambiente virtual la forma de hacerlo es ejecutar\nconda activate desarrollo\nAl ejecutar el comando se puede observar que la leyenda (base) fue sustituida por la leyenda (desarrollo) lo cual nos indica que hemos activado nuestro ambiente virtual.\n\n\n\nDentro de nuestro ambiente virtual podemos instalar las distintas bibliotecas y paquetes que sean necesarios. Por defecto Anaconda tiene un canal para poner a la disposición de la comunidad, que utiliza conda, muchos paquetes. Anaconda es la encargada de verificar que el el desarrollo de dichos paquetes sean de acuerdo a las mismas reglas establecidas por Anaconda. De la misma forma hay distintos canales los cuales tiene paquetes que estan de acuerdo a las reglas establecidas por cada canal. Los distintos canales tienen distintos objetivos por ejemplo contiene las paqueterias desarrolladas relacionadas con desarrollos biomédicos.\nDentro de nuestro ambiente virtual podemos instalar las distintas bibliotecas y paquetes que sean necesarios. Por defecto Anaconda tiene un canal para poner a la disposición de la comunidad, que utiliza conda, muchos paquetes. Anaconda es la encargada de verificar que el desarrollo de dichos paquetes sean de acuerdo a las mismas reglas establecidas por Anaconda. De la misma forma hay distintos canales los cuales tienen paquetes que están de acuerdo a las reglas establecidas por cada canal. Los distintos canales tienen distintos objetivos por ejemplo bioconda contiene las paqueterías desarrolladas relacionadas con desarrollos biomédicos.\nOtro canal muy utilizado es conda-forge, el cual contiene paquetes desarrollados por una extensa comunidad. Por facilidad en este curso utilizaremos el canal conda-forge pues tiene la mayoria de las paqueterías necesarias y se encuentran muchas versiones de los mismos.\n\n\n\nPara instalar un paquete dentro del ambiente virtual es necesario activar el ambiente. Ya dentro de este para hacer la instalación de los distintos paquetes de python tenemos dos formas distintas PIP o conda. PIP es el manejador de paquetes usado por python por defecto si se a trabajado anteriormente con Python lo más seguro es estar familiarizado con su uso.\nconda es el manejador de paquetes del ambiente virtual y nos permite tanto hacer instalar paquetería de python y otras. Por ejemplo podemos instalar R o Julia haciendo uso de conda.\nComo ejemplo para instalar numpy usando conda y el canal conda-forge executamos\n(desarrollo) $ conda install -c conda-forge numpy\n\n\n\n\nJupyter es un conjunto de softwares que nos permite hacer uso de múltiples herramientas, una de sus principales herramientas es el uso de noteboooks los cuales son documentos donde podemos escribir texto plano y hacer ejecución de código. Para que los documentos finales tengan una mayor riqueza se utiliza Markdown y adicionalmente se puede hacer uso de LaTex para escribir fórmulas matemáticas.\nA través del uso de JupyterLab es posible hacer desarrollo de software de forma interactiva usando notebooks, código e información. Esto ayuda al desarrollador a generar un archivo que tiene todo el contexto del desarrollo y entender la forma en la cual el software fue desarrollado, por que se tomaron ciertas decisiones en la creación del código. Esto es particularmente útil en el análisis exploratorio de datos, en la ciencia de datos y en el desarrollo de la inteligencia artificial.\nEl uso de los notebooks ha sido usado principalmente para hacer análisis exploratorios y esto generó la necesidad de poder generar gráficos dentro de los notebooks lo cual nos permite no sólo tener una descripción del código con texto plano sino de manera gráfica poder ver los resultado de los datos analizados. Adicionalmente se puede hacer uso de tiempo de animaciones para complementar las narrativas.\nLos notebooks en cierta forma han ido reemplazando el uso de las terminales interactivas, pues enriquecen la descripción del código y facilitan la visualización. Al tener los mismos beneficios que las terminales interactivas y poder hacer pruebas con pequeños fragmentos de código la presentación del código desarrollado resulta de fácil lectura. Adicionalmente se tienen ciertas herramientas que ayudan al desarrollo las cuales han sido pensadas para los usos más comunes. Conocer todas las funcionalidades de los notebooks de jupyter queda fuera del alcance de este curso pero veremos ciertas cosas básicas para poder trabajar con ellos.\nUsaremos JupyterLab el cual integra una plataforma web para generar notebooks, esta interfaz se hace desplegando un servicio web de forma local y puede ser accedida desde cualquier navegador web. Aunque en este curso se utiliza Python también los notebooks de Jupyter-lab puede hacer uso de distintos lenguajes de programación como son R, Julia.\n\n\nPara su instalación desde un ambiente virtual de conda se ejecuta\n(desarrollo) conda install -c conda-forge -y jupyterlab\nO con pip\n(desarrollo) pip install jupyterlab\n\n\n\nPara iniciar una instancia de JupyterLab desde terminal dentro del ambiente virtual que se genero se hace usando el siguiente comando\n(desarrollo) jupyter-lab\nEn windows también se puede hacer uso de la interfaz gráfica de conda para lanzar el JupyterLab.\n\n\n\n\n\n\nFigure 1: Inicio de JupyterLab\n\n\n\nUna vez ejecutado el comando se desplegará un servicio web el cual se puede acceder desde un navegador y nos mostrará una página web muy similar a la que se muestra en Figure 1.\nPara empezar un nuevo notebook se elige la version de python que se desea que se ejecute y esta generará un nuevo notebook con nombre ‘Untitled.ipynb’ como en Figure 2\n\n\n\n\n\n\nFigure 2: Nuevo Notebook\n\n\n\nEn los notebooks se tienen tres tipos de celdas (‘Code’, ‘Markdown’ y ‘Raw’) las cuales se usan con distintos propósitos.\n\n‘Code’ se utiliza para la ejecución de código\n‘Markdown’ nos permite hacer uso del lenguaje Markdown para enriquecer el texto plano.\n‘Raw’ simplemente va a mostrar el contenido dentro de la celda.\n\nComo ejemplo este curso hace uso de los Notebooks y Markdown, como se ve es de especial utilidad para la creación de texto relacionado con la creación de código y para la generación de manuales técnicos.\n\n\n\nMarkdown es un simple conjunto de instrucciones en texto plano que nos permiten enriquecer el texto para crear documentos más completos. Las siguientes son una muestra de como se utiliza Markdown.\n\n\nLa letra cursiva es un recurso que se utiliza en la creación de texto para resaltar alguna palabra en particular para distinguirla del texto usual. Es común utilizarla para palabras en otro idioma como ballet o software. En el caso de las ciencias es común su uso cuando se hace uso del latín como curriculum vitae.\nPara escribir con negritas en Markdown se utiliza el carácter *, todo lo que se entre los asteríscos queda como cursiva *cursiva*.\n\n\n\nLa letras en negritas nos sirve para resaltas una palabra o palabras del texto normal. Para que el texto este en negritas en Markdown tenemos que colocarlo entre dos asteriscos ** **. De esta forma podemos hacer énfasis **énfasis** en algo particular.\n\n\n\nEn ciertos casos es necesario escribir código dentro del texto sin que este sea ejecutado por tal motivo se utiliza la tilde invertida (`) y nos permite escribir cosas sin que estas sean ejecutadas en los distintos lenguajes soportados por Quarto 1+1 `1+1`.\n\n\n\nPara hacer listas en Markdown es muy fácil pues esto se puede hacer usando un sólo * para definirlas, y un espacio para determina la lista.\n\nCosa 1\nCosa 2\nCossa 3\n\nCosa 3.1\nCosa 3.\n\n\n* Cosa 1\n* Cosa 2\n* Cossa 3\n    * Cosa 3.1\n    * Cosa 3.2\n\n\n\nMarkdown nos permite tener mantener un orden dentro del documento haciendo uso de #, este funciona para indicar un encabezado e inicio de la sección. Markdown nos permite hacer subsecciones a partir del uso consecutivo de #.\n# Sección 1\n\n# Sección 2\n\n# Sección 3\n\n## Sección 3.1\n\n### Sección 3.1.1\n### Sección 3.1.2\n\n## Sección 3.2 \n## Sección 3.3\n\n# Sección 4\n\n\n\n\nMarkdown nos permite hacer tablas referencia insertar imagenes, etc. Se puede hacer un curso para conocer los distintos usos de forma más extensiva, pero queda fuera del alcance de este curso.\n\n\n\n\nGit es un sistema de control de versiones, aunque existen distintos sistemas de control de versiones, Git es el más utilizado. Los sistemas de control de versiones son una herramienta fundamental en el desarrollo de software pues nos permiten tener un control sobre las versiones del código desarrollado a través de los cambios en el código. A través del seguimiento de dichos cambios es posible tener un trabajo en equipo sobre el mismo archivo de forma autónoma permitiendo un desarrollo más rápido.\nUna de las herramientas más usadas en los sistemas de control de versiones es la idea básica para lo que fueron creados que es poder regresar a una versión anterior en el desarrollo de software, lo cual resulta fundamental si hay un error en el desarrollo (bug).\nSe recomienda tener una mejor comprensión de los mismos. Por desgracia esto queda fuera del campo de este curso y sólo daremos una explicación simplificada de esto.\nExisten distintos servicios para almacenar código de manera remota dentro de los cuales podemos destacar github y gitlab. En este curso se utiliza github por facilidad pues se usa su servicio de github-pages para tener en linea la documentación del paquete que se desarrolla.\nPara la instalación de git dentro de un ambiente virtual de anaconda se puede hacer de la siguiente forma\n(desarrollo) conda install -c conda-forge git\nLo más seguro es que git ya se encuentre instalado en su sistemas, al menos es el caso para Mac y Linux. Para saber si se tiene instalado git se puede abrir una terminal y ejecutar:\ngit version\nEste comando mostrará la versión instalada dentro del sistema.\nEn caso de que no se tenga instalado se puede seguir los pasos que se encuentran en Github o se puede descargar desde https://git-scm.com/download/win. Usando cualquiera de los dos métodos su instalación será de forma global, en caso de desear instalarlo dentro de una ambiente virtual se puede hacer con conda o usando el canal oficial de anaconda:\nconda install -c anaconda git\no el canal de la comunidad conda-forge:\nconda install -c conda-forge git\n\n\nA continuación solo enlistamos ciertos comandos de git pues su uso completo se encuentra fuera del alcance de este curso, en la sección se describen un poco más.\n\ngit clone sirve poara clonar repositorios.\ngit pull sirve para traer los cambios desde el servidor de git. El servidor depende de donde se tiene el servicio (github, gitlab o similares).\ngit add &lt;archivo&gt; añade el archivo que se modificó y que se desea que actualizar, o bien se añade el archivo si no se tiene dentro de nuesto conjunto de archivos vigilados.\ngit commit -a “Comitea” todos los cambios en de los archivos añadidos anteriormente de forma local.\ngit push Sube los cambios hechos a el servidor de git, en nuestro caso lo va a subir a github pues el es servicio que determinamos usar.\ngit status nos dice los archivos que han sido añadidos cuales se estan vigilando pero sus cambios no han sido añadidos y cuales no se estan vigilando.\n\n\n\n\n\nLa instalación de nbdev es igual de fácil que los anteriores paquetes, pero en este caso se utiliza el canal de la empresa que desarrolla nbdev. Se instala a través de pip usando:\npip install nbdev\no instalar con conda:\nconda install -c fastai nbdev\n\n\n\nLa instalación en Windows es distinta pues es necesario hacerla desde PIP y usar una version especifica, al momento de escribir este curso la instalación disponible a través de PIP no funciona de forma totalmente correcta, por tal motivo vamos a especificar la version para hacer uso de esta.\npip install nbdev=2.3.12\n\n\n\nQuarto es un sistema que nos permite utilizar las utilidades de los notebook de markdown, en particular usar los notebooks de jupyter, y todas sus utilidades. Quarto esta construido sobre pandoc el cual permite convertir entre distintos tipos de documentos, en particular distintos tipos de Markdown, esto permite utilizar las herramientas desarrolladas en Quarto y traducir estos los notebooks a otro tipo de documentos.\nCon esta idea los desarrolladores de nbdev utilizan Quarto para generar documentos html utilizando y poder generar la documentación necesaria de una biblioteca siguiendo la idea de programacion literal.\n\n\n\nYa con la instalación de nbdev un comando del mismo nos permite instalar Quarto en el caso de Mac o Linux esto se puede hacer una vez instalado nbdev usando el comando\nnbdev_install_quarto\n\n\nSi se desea se puede instalar siguiendo los siguientes pasos para usar con el IDE de preferencia. Esta instalación tendra disponible Quarto en todo el sistema y no sólo para el ambiente de desarrollo. Aunque es posible hacer la instalación dentro de un ambiente de desarrollo, esto queda fuera de de una explicación básica.\n\n\n\nEs recomendable instalar ciertos plug-ins para hacernos la vida más fácil estos se hace ejecutando,\nnbdev_install_hooks",
    "crumbs": [
      "Contenido",
      "Instalación prerequisitos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2/Instalacion_rapida.html#ambientes-virtuales-conda-tema-2.1",
    "href": "contenido/Contenido/Tema2/Instalacion_rapida.html#ambientes-virtuales-conda-tema-2.1",
    "title": "Curso Nbdev Introducción",
    "section": "",
    "text": "Anaconda es una empresa la cual desarrolló un manejador de ambientes virtuales con un manejador de paquetes (conda), éste nos permite la creación de ambientes virtuales. Dentro de dichos ambientes se puede hacer un manejo eficiente de los diferentes softwares instalados dentro del ambiente virtual y las dependencias de los mismos. Al tener un manejo eficiente de las paqueterias y las dependencias dentro de este se hace más fácil la creación de ambientes de desarrollo.\nDe esta forma algo instalado dentro de un ambiente virtual no afectará a las distintas paqueterías que se encuentran fuera del ambiente virtual. Lo cual nos permite tener tener aislado un ambiente de desarrollo con respecto al sistema operativo u otro ambiente de desarrollo.\n\n\nPara la instalación de conda lo más sencillo es seguir el este manual aquí sólo se hace un esbozo de la instalación.\n\nBajar el instalador:\n\nAnaconda para windows.\n\nVerificar que se ha bajano correctamente (ver ).\nHacer doble click en el archivo .exe (similar a Anaconda3-######-Windows-x86_64.exe). Para la instalación en Linux o Mac se debe de bajar el archivo Anaconda3-####-Linux-###.sh o bien el Anaconda3-####-MACOSX-###.sh y ejecutar el archivo usando la terminal.\nSeguir las instrucciones en la pantalla en caso de windows. Y seguir las instrucciones que aparecerán en caso del uso de la terminal.\nPara probar la instalación abra la terminal de windows (cmd) o el anaconda prompt y corra el comando conda list. Una lista de paquetes aparecerá si se instaló de forma correcta.\n\n\n\n\nPara generar un ambiente virtual usando anaconda se puede hacer a través de la terminal. En caso de windows se puede hacer llamando a Anaconda Prompt.\nDentro de la terminal se puede observar que antes del símbolo del sistema aparece la leyenda (base) esta no indica que estamos usando el ambiente virtual base.\nPara crear un nuevo ambiente virtual se ejecuta la siguiente linea en la linea de comandos.\nconda create -n desarrollo\nEste comando crea un nuevo ambiente virtual llamado desarrollo. Se puede especificar la versión de python a instalar dentro del ambiente virtual. También es posible instalar otros lenguajes de programación dentro del ambiente virtual como son R o Julia.\nPara entrar al ambiente virtual la forma de hacerlo es ejecutar\nconda activate desarrollo\nAl ejecutar el comando se puede observar que la leyenda (base) fue sustituida por la leyenda (desarrollo) lo cual nos indica que hemos activado nuestro ambiente virtual.\n\n\n\nDentro de nuestro ambiente virtual podemos instalar las distintas bibliotecas y paquetes que sean necesarios. Por defecto Anaconda tiene un canal para poner a la disposición de la comunidad, que utiliza conda, muchos paquetes. Anaconda es la encargada de verificar que el el desarrollo de dichos paquetes sean de acuerdo a las mismas reglas establecidas por Anaconda. De la misma forma hay distintos canales los cuales tiene paquetes que estan de acuerdo a las reglas establecidas por cada canal. Los distintos canales tienen distintos objetivos por ejemplo contiene las paqueterias desarrolladas relacionadas con desarrollos biomédicos.\nDentro de nuestro ambiente virtual podemos instalar las distintas bibliotecas y paquetes que sean necesarios. Por defecto Anaconda tiene un canal para poner a la disposición de la comunidad, que utiliza conda, muchos paquetes. Anaconda es la encargada de verificar que el desarrollo de dichos paquetes sean de acuerdo a las mismas reglas establecidas por Anaconda. De la misma forma hay distintos canales los cuales tienen paquetes que están de acuerdo a las reglas establecidas por cada canal. Los distintos canales tienen distintos objetivos por ejemplo bioconda contiene las paqueterías desarrolladas relacionadas con desarrollos biomédicos.\nOtro canal muy utilizado es conda-forge, el cual contiene paquetes desarrollados por una extensa comunidad. Por facilidad en este curso utilizaremos el canal conda-forge pues tiene la mayoria de las paqueterías necesarias y se encuentran muchas versiones de los mismos.\n\n\n\nPara instalar un paquete dentro del ambiente virtual es necesario activar el ambiente. Ya dentro de este para hacer la instalación de los distintos paquetes de python tenemos dos formas distintas PIP o conda. PIP es el manejador de paquetes usado por python por defecto si se a trabajado anteriormente con Python lo más seguro es estar familiarizado con su uso.\nconda es el manejador de paquetes del ambiente virtual y nos permite tanto hacer instalar paquetería de python y otras. Por ejemplo podemos instalar R o Julia haciendo uso de conda.\nComo ejemplo para instalar numpy usando conda y el canal conda-forge executamos\n(desarrollo) $ conda install -c conda-forge numpy",
    "crumbs": [
      "Contenido",
      "Instalación prerequisitos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalar-jupyter-notebook-tema-2.2",
    "href": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalar-jupyter-notebook-tema-2.2",
    "title": "Curso Nbdev Introducción",
    "section": "",
    "text": "Jupyter es un conjunto de softwares que nos permite hacer uso de múltiples herramientas, una de sus principales herramientas es el uso de noteboooks los cuales son documentos donde podemos escribir texto plano y hacer ejecución de código. Para que los documentos finales tengan una mayor riqueza se utiliza Markdown y adicionalmente se puede hacer uso de LaTex para escribir fórmulas matemáticas.\nA través del uso de JupyterLab es posible hacer desarrollo de software de forma interactiva usando notebooks, código e información. Esto ayuda al desarrollador a generar un archivo que tiene todo el contexto del desarrollo y entender la forma en la cual el software fue desarrollado, por que se tomaron ciertas decisiones en la creación del código. Esto es particularmente útil en el análisis exploratorio de datos, en la ciencia de datos y en el desarrollo de la inteligencia artificial.\nEl uso de los notebooks ha sido usado principalmente para hacer análisis exploratorios y esto generó la necesidad de poder generar gráficos dentro de los notebooks lo cual nos permite no sólo tener una descripción del código con texto plano sino de manera gráfica poder ver los resultado de los datos analizados. Adicionalmente se puede hacer uso de tiempo de animaciones para complementar las narrativas.\nLos notebooks en cierta forma han ido reemplazando el uso de las terminales interactivas, pues enriquecen la descripción del código y facilitan la visualización. Al tener los mismos beneficios que las terminales interactivas y poder hacer pruebas con pequeños fragmentos de código la presentación del código desarrollado resulta de fácil lectura. Adicionalmente se tienen ciertas herramientas que ayudan al desarrollo las cuales han sido pensadas para los usos más comunes. Conocer todas las funcionalidades de los notebooks de jupyter queda fuera del alcance de este curso pero veremos ciertas cosas básicas para poder trabajar con ellos.\nUsaremos JupyterLab el cual integra una plataforma web para generar notebooks, esta interfaz se hace desplegando un servicio web de forma local y puede ser accedida desde cualquier navegador web. Aunque en este curso se utiliza Python también los notebooks de Jupyter-lab puede hacer uso de distintos lenguajes de programación como son R, Julia.\n\n\nPara su instalación desde un ambiente virtual de conda se ejecuta\n(desarrollo) conda install -c conda-forge -y jupyterlab\nO con pip\n(desarrollo) pip install jupyterlab\n\n\n\nPara iniciar una instancia de JupyterLab desde terminal dentro del ambiente virtual que se genero se hace usando el siguiente comando\n(desarrollo) jupyter-lab\nEn windows también se puede hacer uso de la interfaz gráfica de conda para lanzar el JupyterLab.\n\n\n\n\n\n\nFigure 1: Inicio de JupyterLab\n\n\n\nUna vez ejecutado el comando se desplegará un servicio web el cual se puede acceder desde un navegador y nos mostrará una página web muy similar a la que se muestra en Figure 1.\nPara empezar un nuevo notebook se elige la version de python que se desea que se ejecute y esta generará un nuevo notebook con nombre ‘Untitled.ipynb’ como en Figure 2\n\n\n\n\n\n\nFigure 2: Nuevo Notebook\n\n\n\nEn los notebooks se tienen tres tipos de celdas (‘Code’, ‘Markdown’ y ‘Raw’) las cuales se usan con distintos propósitos.\n\n‘Code’ se utiliza para la ejecución de código\n‘Markdown’ nos permite hacer uso del lenguaje Markdown para enriquecer el texto plano.\n‘Raw’ simplemente va a mostrar el contenido dentro de la celda.\n\nComo ejemplo este curso hace uso de los Notebooks y Markdown, como se ve es de especial utilidad para la creación de texto relacionado con la creación de código y para la generación de manuales técnicos.\n\n\n\nMarkdown es un simple conjunto de instrucciones en texto plano que nos permiten enriquecer el texto para crear documentos más completos. Las siguientes son una muestra de como se utiliza Markdown.\n\n\nLa letra cursiva es un recurso que se utiliza en la creación de texto para resaltar alguna palabra en particular para distinguirla del texto usual. Es común utilizarla para palabras en otro idioma como ballet o software. En el caso de las ciencias es común su uso cuando se hace uso del latín como curriculum vitae.\nPara escribir con negritas en Markdown se utiliza el carácter *, todo lo que se entre los asteríscos queda como cursiva *cursiva*.\n\n\n\nLa letras en negritas nos sirve para resaltas una palabra o palabras del texto normal. Para que el texto este en negritas en Markdown tenemos que colocarlo entre dos asteriscos ** **. De esta forma podemos hacer énfasis **énfasis** en algo particular.\n\n\n\nEn ciertos casos es necesario escribir código dentro del texto sin que este sea ejecutado por tal motivo se utiliza la tilde invertida (`) y nos permite escribir cosas sin que estas sean ejecutadas en los distintos lenguajes soportados por Quarto 1+1 `1+1`.\n\n\n\nPara hacer listas en Markdown es muy fácil pues esto se puede hacer usando un sólo * para definirlas, y un espacio para determina la lista.\n\nCosa 1\nCosa 2\nCossa 3\n\nCosa 3.1\nCosa 3.\n\n\n* Cosa 1\n* Cosa 2\n* Cossa 3\n    * Cosa 3.1\n    * Cosa 3.2\n\n\n\nMarkdown nos permite tener mantener un orden dentro del documento haciendo uso de #, este funciona para indicar un encabezado e inicio de la sección. Markdown nos permite hacer subsecciones a partir del uso consecutivo de #.\n# Sección 1\n\n# Sección 2\n\n# Sección 3\n\n## Sección 3.1\n\n### Sección 3.1.1\n### Sección 3.1.2\n\n## Sección 3.2 \n## Sección 3.3\n\n# Sección 4\n\n\n\n\nMarkdown nos permite hacer tablas referencia insertar imagenes, etc. Se puede hacer un curso para conocer los distintos usos de forma más extensiva, pero queda fuera del alcance de este curso.",
    "crumbs": [
      "Contenido",
      "Instalación prerequisitos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalacion-de-git-github-tema-2.3",
    "href": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalacion-de-git-github-tema-2.3",
    "title": "Curso Nbdev Introducción",
    "section": "",
    "text": "Git es un sistema de control de versiones, aunque existen distintos sistemas de control de versiones, Git es el más utilizado. Los sistemas de control de versiones son una herramienta fundamental en el desarrollo de software pues nos permiten tener un control sobre las versiones del código desarrollado a través de los cambios en el código. A través del seguimiento de dichos cambios es posible tener un trabajo en equipo sobre el mismo archivo de forma autónoma permitiendo un desarrollo más rápido.\nUna de las herramientas más usadas en los sistemas de control de versiones es la idea básica para lo que fueron creados que es poder regresar a una versión anterior en el desarrollo de software, lo cual resulta fundamental si hay un error en el desarrollo (bug).\nSe recomienda tener una mejor comprensión de los mismos. Por desgracia esto queda fuera del campo de este curso y sólo daremos una explicación simplificada de esto.\nExisten distintos servicios para almacenar código de manera remota dentro de los cuales podemos destacar github y gitlab. En este curso se utiliza github por facilidad pues se usa su servicio de github-pages para tener en linea la documentación del paquete que se desarrolla.\nPara la instalación de git dentro de un ambiente virtual de anaconda se puede hacer de la siguiente forma\n(desarrollo) conda install -c conda-forge git\nLo más seguro es que git ya se encuentre instalado en su sistemas, al menos es el caso para Mac y Linux. Para saber si se tiene instalado git se puede abrir una terminal y ejecutar:\ngit version\nEste comando mostrará la versión instalada dentro del sistema.\nEn caso de que no se tenga instalado se puede seguir los pasos que se encuentran en Github o se puede descargar desde https://git-scm.com/download/win. Usando cualquiera de los dos métodos su instalación será de forma global, en caso de desear instalarlo dentro de una ambiente virtual se puede hacer con conda o usando el canal oficial de anaconda:\nconda install -c anaconda git\no el canal de la comunidad conda-forge:\nconda install -c conda-forge git\n\n\nA continuación solo enlistamos ciertos comandos de git pues su uso completo se encuentra fuera del alcance de este curso, en la sección se describen un poco más.\n\ngit clone sirve poara clonar repositorios.\ngit pull sirve para traer los cambios desde el servidor de git. El servidor depende de donde se tiene el servicio (github, gitlab o similares).\ngit add &lt;archivo&gt; añade el archivo que se modificó y que se desea que actualizar, o bien se añade el archivo si no se tiene dentro de nuesto conjunto de archivos vigilados.\ngit commit -a “Comitea” todos los cambios en de los archivos añadidos anteriormente de forma local.\ngit push Sube los cambios hechos a el servidor de git, en nuestro caso lo va a subir a github pues el es servicio que determinamos usar.\ngit status nos dice los archivos que han sido añadidos cuales se estan vigilando pero sus cambios no han sido añadidos y cuales no se estan vigilando.",
    "crumbs": [
      "Contenido",
      "Instalación prerequisitos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalación-nbdev-rápida-linux-o-mac-tema-2.4",
    "href": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalación-nbdev-rápida-linux-o-mac-tema-2.4",
    "title": "Curso Nbdev Introducción",
    "section": "",
    "text": "La instalación de nbdev es igual de fácil que los anteriores paquetes, pero en este caso se utiliza el canal de la empresa que desarrolla nbdev. Se instala a través de pip usando:\npip install nbdev\no instalar con conda:\nconda install -c fastai nbdev",
    "crumbs": [
      "Contenido",
      "Instalación prerequisitos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalación-no-tan-rápida-windows",
    "href": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalación-no-tan-rápida-windows",
    "title": "Curso Nbdev Introducción",
    "section": "",
    "text": "La instalación en Windows es distinta pues es necesario hacerla desde PIP y usar una version especifica, al momento de escribir este curso la instalación disponible a través de PIP no funciona de forma totalmente correcta, por tal motivo vamos a especificar la version para hacer uso de esta.\npip install nbdev=2.3.12",
    "crumbs": [
      "Contenido",
      "Instalación prerequisitos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2/Instalacion_rapida.html#quarto-tema-2.5",
    "href": "contenido/Contenido/Tema2/Instalacion_rapida.html#quarto-tema-2.5",
    "title": "Curso Nbdev Introducción",
    "section": "",
    "text": "Quarto es un sistema que nos permite utilizar las utilidades de los notebook de markdown, en particular usar los notebooks de jupyter, y todas sus utilidades. Quarto esta construido sobre pandoc el cual permite convertir entre distintos tipos de documentos, en particular distintos tipos de Markdown, esto permite utilizar las herramientas desarrolladas en Quarto y traducir estos los notebooks a otro tipo de documentos.\nCon esta idea los desarrolladores de nbdev utilizan Quarto para generar documentos html utilizando y poder generar la documentación necesaria de una biblioteca siguiendo la idea de programacion literal.",
    "crumbs": [
      "Contenido",
      "Instalación prerequisitos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalar-quarto",
    "href": "contenido/Contenido/Tema2/Instalacion_rapida.html#instalar-quarto",
    "title": "Curso Nbdev Introducción",
    "section": "",
    "text": "Ya con la instalación de nbdev un comando del mismo nos permite instalar Quarto en el caso de Mac o Linux esto se puede hacer una vez instalado nbdev usando el comando\nnbdev_install_quarto\n\n\nSi se desea se puede instalar siguiendo los siguientes pasos para usar con el IDE de preferencia. Esta instalación tendra disponible Quarto en todo el sistema y no sólo para el ambiente de desarrollo. Aunque es posible hacer la instalación dentro de un ambiente de desarrollo, esto queda fuera de de una explicación básica.\n\n\n\nEs recomendable instalar ciertos plug-ins para hacernos la vida más fácil estos se hace ejecutando,\nnbdev_install_hooks",
    "crumbs": [
      "Contenido",
      "Instalación prerequisitos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "A continuación vamos a poner los pasos que vamos a seguir para crear un ambiente de desarrollo y automatizar todos los procesos.\n\nGenerar un repositorio.\nHabilitar Github Pages.\nHacer la primera edición.\nVer la documnetación local\nConstruir módulos.\nAñadir cambios Github\n\n\n\n\nLos repositorios nos permiten mantener un orden en el código y un control de cambios, por la simpleza usaremos Github donde alojaremos el repositorio de nuestro desarrollo. Para poder crear un repositorio dentro de github será necesario crear una cuenta dentro del sitio.\n\n\n\n\n\n\nFigure 1: Nuevo repositorio\n\n\n\nUna vez creado nuestro repositorio se utiliza el siguiente comando para clonar el repositorio de forma local y poder modificarlo tanto de forma local como actualizar los cambios en github.\ngit clone git@github.com:%nombreusuario/nbdev_prueba.git\nPodemos observar que no hay nada dentro del repositorio, incluso cuando se ejecuta el código anterior nos muestra una advertencia que estamos clonando un repositorio vacío.\nwarning: You appear to have cloned an empty repository.\nNbdev contiene un comando para añadir toda la estructura necesaria para poder generar un paquete muestra junto con su documentación. Este nos ayudará como base para el nuestro.\nnbdev_new\nEste comando deberá ejecutarse dentro del directorio del repositorio. El comando generará tres subdirectorios:\n\nUn subdirectorio con el nombre del repositorio (nbdev_prueba)\nnbs\n_proc\n\nY los siguientes archivos\n\nLicense\nMANIFEST.in\nREADME.md\nsettings.ini\nsetup.py\n\nDe los anteriores, el que nos interesa es el settings.ini, en el cual se controla la mayoría de las cosas dentro de nuestro paquete.\nVamos a modificar nuestro repositorio en github para ver que todo se sincronize y funcione.\n$ git add .\n$ git commit -m 'Primer commit'\n$ git push\nSi vamos a nuestro repositorio dentro de Github podemos observar que ya tenemos los archivos y los subdirectorios en Github igual que lo tenemos dentro de nuestros archivos locales Ver ?@fig-nbd-modificado.\n\n\n\nNuevo repositorio\n\n\n\n\n\nUna de cosa que nos promete nbdev es la generación de documentación, pero es necesario tener un lugar donde se pueda consultar. Un lugar donde podemos tener alojada la documentación es en Github Pages la cual nos permite generar un sitio web con la documentación desde el repositorio.\n\n\n\n\n\n\nNote\n\n\n\nAunque nbdev tiene por defecto el uso de Github Pages esto puede ser modificado y tener alojada la documentación en otra parte.\n\n\nPara habilitar en el repositorio hay que ir a la parte de “Settings” del repositorio y en el menú (Izquierda) en “Pages”. En esta sección se cambia de “Branch” a “gh-pages” y se da click en “Save”.\n\n\n\nNuevo repositorio\n\n\nLa página se encuentra alojada en una dirección similar a https://%nombreusuario.github.io/nbdev_prueba/. Pero ésta primero debe ser generada por Github.\nUUna de las características de Github es que podemos generar ciertas acciones y flujos de trabajo de forma automatizada dentro del repositorio. Estas acciones nos permiten verificar que tanto el código del paquete funcione de manera adecuada, como el despliegue de nuestra documentación se haga de forma correcta. Integrando esto evitamos el desgaste de hacerlo de forma manual.\nCuando nuestra página de documentación se encuentre disponible en la pestaña de “Actions” del repositorio podremos ver (✅) en “pages build and deployment”. En caso de que se vea (❌) significa que algo ha salido mal.\n\n\n\nDeploy documentacion\n\n\nPara poder ver la documentación que se creo, nos podemos dirigir a la página la cual estará alojada en una direccion similar a https://%nombreusuario.github.io/nbdev_prueba/\n\n\n\nDocumentacion\n\n\n\n\n\n\n\n\nIntegración continua\nAl tener todo integrado facilitamos el trabajo del desarrollador, aprovechando el tiempo y librando de tareas que pueden resultar engorrosas y que lleva tiempo realizar.\n\n\n\n\n\n\nYa que hemos generado un repositorio y hemos modificado las configuraciones para tener la documentación alojada de forma automática vamos a hacer la primera edición a nuestro paquete.\n\n\nAntes de esto vamos a ejecutar el siguiente comando:\n$ nbdev_install_hooks\nEste comando instala ciertas extensiones en Jupyter Notebook y JupyterLab, las cuales nos permitirán limpiar los notebooks de metadatos que no son necesarios en los repositorios. Y arreglar ciertos elementos de los notebooks los cuales pueden llegar a causar conflictos cuando se hace uso de las acciones de git.\nEsto nos ayuda, pues es común que ciertos datos se modifiquen sin haber editado el notebook, esto sucede por el simple hecho de hacer su ejecución o abrir el notebook.\n\nnbdev_merge Nos ayuda a poner los notebooks de forma que al hacer el uso de acciones de pull merge, rebase o stash dentro de git, no modifiquen los notebooks y estos se puedan ejecutar entre los colaboradores del repositorio.\nnbdev_clean Los notebooks de Jupyter incluyen muchos metadatos que no se llevan bien con sistemas de control como git. Por tal motivo nbdev installa un “hook” el cual elimina estos metadatos o los reemplaza por versiones genéricas que no afectan la ejecución o visualizaciones dentro del notebook.\nnbdev_trust Un efecto secundario que se tiene al hacer uso de los notebooks de Jupyter es que estos no funcionan dentro de repositorios compartidos. La razón es que estos pueden ejecutar código HTML o código de JavaScript el cual puede llegar a contener código malicioso. Por tal motivo el comportamiento por defecto de los notebooks de Jupyter es preguntar si se puede confiar en el notebook cada vez que se abre esto puede ser una problemática en el flujo de trabajo por tal motivo se puede correr nbdev_trust para evitar que cada vez que se abre un notebook pregunte si es de confianza.\n\n\n\n\n\n\n\nCaution\n\n\n\nAdvertencia\nNo se debe de usar los hooks de nbdev dentro de un repositorio que no se confie.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nLos hooks de nbdev funcionan para cualquier repositorio, sin importar si se usa nbdev o no para generar un paquete o biblioteca.\n\n\n\n\n\n\nNbdev es muy modificable, esto se encuentra dentro del archivo settings.ini. Para crear el archivo se puede ejecutar nbdev_create_config.\n\n\n\nAbrimos el archivo nbs/00_core.ipynb, el cual se generó cuando ejecutamos nbdev_new. Dentro de éste se pueden observar las directrices más importantes para generar un documento que nos servirá para poder hacer tanto nuestro paquete, la documentación y su empaquetado.\nExpliquemos el comportamiento de las celdas que se encuentran dentro de este notebook.\nLa primera celda contiene\n# core\n\n&gt; Fill in a module description here\nAquí definimos que el módulo a crear se llamará core y la descripción del mismo. La celda contiene un encabezado H1 de Markdown # y una cita de Markdown donde se describe el módulo.\nLa segunda celda\n#| default_exp core\nEs una directriz en la cual se decide el módulo al cual el notebook exportará lo que se desee. Como se encuentra se exporta al módulo core.\nEn la siguiente celda\n#| hide\nfrom nbdev.showdoc import *\nLa directriz #| hide nos dice que esta celda no parecerá y tampoco la salida de la misma. Esto nos sirve para poder hacer ciertas pruebas pero que no se desean que sean exportadas ni que sean parte de la documentación.\nEn la celda siguiente\n#| export\ndef foo(): pass\n#| export exportará el contenido de la celda al módulo.\nLa última celda\n#| hide\nimport nbdev; nbdev.nbdev_export()\nusa la directriz #| hide para ocultar el código y la salida de la celda, lo que se ejecuta dentro de la celda es lo que permite exportar lo que se indicó dentro del notebook al módulo.\nVamos a modificar este notebook para hacer un módulo con funciones sencillas.\nAgregamos las siguientes celdas antes de la última celda en el notebook sin editar.\n#| export\ndef saludo():\n    \"\"\"Imprime Hola\"\"\"\n    print('Hola!')\n    return\nsaludo()\n#| export\ndef saludo_a(to):\n    \"\"\"Imprime hola a un nombre\"\"\"\n    print('Hola!', to)\n    \n    print('Espero que te encuentres bien')\n    return\nsaludo_a('Raul')\nshow_doc(saludo_a)\nLas celdas sin la directriz #| export nos pueden servir para probar las funcionalidades dentro del módulo o bien para ser parte de la documentación como ejemplos. En la celda se utiliza la función show_doc nos sirve para mostrar el uso de la documentación interna de la función saludo_a esta nos sirve para generar una documentación precisa.\nAhora podemos executar todo el notebook usando el boton ⏩ dentro de jupyterlab. Si todo funciona correctamente podemos generar la documentación, hacer pruebas y exportar a un módulo.\n\n\n\n\nPara poder ver la documentación de forma local se ejecuta el siguiente comando desde el folder del repositorio\n$ nbdev_preview\nEl comando construye la documentación usando los notebooks que se encuentran dentro del directorio ‘nbs/’. Y genera un servicio de página web de forma local a la cual podemos acceder desde nuestro navegador.\nLa configuración se puede controlar desde el archivo settings.ini y por defecto toma a ‘nbs/index.ipynb’ como la pagina principal. A la izquierda nos muestra una columna donde podemos ir a la documentación del modulo “core”. Podremos observar que se encuentran las modificaciónes que se hicieron al módulo.\nSi se mantiene en servicio la página es posible ver los cambios que se hacen con cierto retraso.\n\n\n\nDocumentacion Modificada\n\n\n\n\n\nPara probar que el todos los elementos del módulo funciona de forma correcta y si alguna modificación hecha no afecta en el desempeño de los componentes de los módulos en nuestro proyecto se utiliza el siguiente comando\n$ nbdev_test\nSi todo está correcto en la consola se desplegará\nSuccess.\nEn caso contrario se muestran los errores y se especifica los notebook en donde se encuentran.\nnbdev_test puede usarse para probar de manera individual los notebooks\n$ nbdev_test --path notebook.ipynb\nO para todo un directorio\n$ nbdev_test --path tests/\n\n\n\nPara generar la documentación, desde la línea de comandos en el directorio de nuestro repositorio se llama el comando:\n$ nbdev_export\nEste comando genera nuestro módulo ‘core’ el cual se encontrará dentro del directorio ‘nbdev_prueba’. Si se desea se pueda abrir el archivo core.py el cual contiene una leyenda\n&gt;  # AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.\ninformando que el archivo fue autogenerado y que cualquier modificación debe de hacerse dentro del notebook nbs/00_core.ipynb.\nEn el archivo core.py podemos ver que se encuentran las funciones definidas dentro del notebook en las celdas con la directriz #| export.\nEl módulo generado forma parte de la nuestro proyecto.\nPor defecto al ejecutar nbdev_export se ejecuntan todos los notebooks del projecto. También se puede hacer sobre un notebook en específico.\nnbdev_export --path notebook.ipynb\no un directorio\nnbdev_export --path dir/\nEsto sólo sucedera si al principio del notebook se añade la directriz #| default_exp core al principio del notebook.\n\n\n\nPara mantener el código usando Github limpiamos los notebooks con\n$ nbdev_clean\nEl comportamiento usual es limpiar todos los notebook que se encuentran en el directorio declarado en el archivo settings.ini en la parte de nbdev nbs_path = nbs pero también puede se puede limpiar un sólo notebook.\n$ nbdev_clean --fname notebook.ipynb\nTambién podemos ejecutar\n$ nbdev_readme \nel cual actualiza el Readme.md del repositorio.\n\n\n\nYa podemos hacer los ‘commits’ y ‘push’ a los cambios en el repositorio para que éstos se actualizen en Github. Nbdev nos da un comando para hacer todo para disminuir el tiempo para los cambios. Esto se puede hacer usando\n$ nbdev_prepare \nel cual exporta, prueba, limpia los notebooks y modifica el README del repositorio\n$ git add .\n$ git commit -m 'El primer commit con modificaciones' # Cambie el texto por el que se desee\n$ git push\n\n\nLa biblioteca se puede añadir a PIP o Anaconda en cualquiera de los casos es necesario tener una cuenta para hacer estas acciones.\nEn este caso se dan los pasos para hacer las instalación desde github usando pip install.\npip install \"Nombre\" @ git+\"URL del repositorio\"\nEn nuestro caso\npip install nbdev-prueba@git+https://github.com/\"Nombre_usuario_github\"/nbdev_prueba\nDe esta forma ya tenemos la biblioteca instalada dentro de nuestro ambiente de python. Para ver esto podemos abrir una terminal de python e importar el módulo core de nuestra biblioteca.\nfrom nbdev_prueba import core\ncore.saludo_a('Juan')\nY obtenemos como resultado\nHola! Juan\nEspero que te encuentres bien",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html#cómo-me-organizo",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html#cómo-me-organizo",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "A continuación vamos a poner los pasos que vamos a seguir para crear un ambiente de desarrollo y automatizar todos los procesos.\n\nGenerar un repositorio.\nHabilitar Github Pages.\nHacer la primera edición.\nVer la documnetación local\nConstruir módulos.\nAñadir cambios Github",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html#generar-un-repositorio.",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html#generar-un-repositorio.",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "Los repositorios nos permiten mantener un orden en el código y un control de cambios, por la simpleza usaremos Github donde alojaremos el repositorio de nuestro desarrollo. Para poder crear un repositorio dentro de github será necesario crear una cuenta dentro del sitio.\n\n\n\n\n\n\nFigure 1: Nuevo repositorio\n\n\n\nUna vez creado nuestro repositorio se utiliza el siguiente comando para clonar el repositorio de forma local y poder modificarlo tanto de forma local como actualizar los cambios en github.\ngit clone git@github.com:%nombreusuario/nbdev_prueba.git\nPodemos observar que no hay nada dentro del repositorio, incluso cuando se ejecuta el código anterior nos muestra una advertencia que estamos clonando un repositorio vacío.\nwarning: You appear to have cloned an empty repository.\nNbdev contiene un comando para añadir toda la estructura necesaria para poder generar un paquete muestra junto con su documentación. Este nos ayudará como base para el nuestro.\nnbdev_new\nEste comando deberá ejecutarse dentro del directorio del repositorio. El comando generará tres subdirectorios:\n\nUn subdirectorio con el nombre del repositorio (nbdev_prueba)\nnbs\n_proc\n\nY los siguientes archivos\n\nLicense\nMANIFEST.in\nREADME.md\nsettings.ini\nsetup.py\n\nDe los anteriores, el que nos interesa es el settings.ini, en el cual se controla la mayoría de las cosas dentro de nuestro paquete.\nVamos a modificar nuestro repositorio en github para ver que todo se sincronize y funcione.\n$ git add .\n$ git commit -m 'Primer commit'\n$ git push\nSi vamos a nuestro repositorio dentro de Github podemos observar que ya tenemos los archivos y los subdirectorios en Github igual que lo tenemos dentro de nuestros archivos locales Ver ?@fig-nbd-modificado.\n\n\n\nNuevo repositorio",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html#habilitar-github-pages-y-flujos-de-trabajo",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html#habilitar-github-pages-y-flujos-de-trabajo",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "Una de cosa que nos promete nbdev es la generación de documentación, pero es necesario tener un lugar donde se pueda consultar. Un lugar donde podemos tener alojada la documentación es en Github Pages la cual nos permite generar un sitio web con la documentación desde el repositorio.\n\n\n\n\n\n\nNote\n\n\n\nAunque nbdev tiene por defecto el uso de Github Pages esto puede ser modificado y tener alojada la documentación en otra parte.\n\n\nPara habilitar en el repositorio hay que ir a la parte de “Settings” del repositorio y en el menú (Izquierda) en “Pages”. En esta sección se cambia de “Branch” a “gh-pages” y se da click en “Save”.\n\n\n\nNuevo repositorio\n\n\nLa página se encuentra alojada en una dirección similar a https://%nombreusuario.github.io/nbdev_prueba/. Pero ésta primero debe ser generada por Github.\nUUna de las características de Github es que podemos generar ciertas acciones y flujos de trabajo de forma automatizada dentro del repositorio. Estas acciones nos permiten verificar que tanto el código del paquete funcione de manera adecuada, como el despliegue de nuestra documentación se haga de forma correcta. Integrando esto evitamos el desgaste de hacerlo de forma manual.\nCuando nuestra página de documentación se encuentre disponible en la pestaña de “Actions” del repositorio podremos ver (✅) en “pages build and deployment”. En caso de que se vea (❌) significa que algo ha salido mal.\n\n\n\nDeploy documentacion\n\n\nPara poder ver la documentación que se creo, nos podemos dirigir a la página la cual estará alojada en una direccion similar a https://%nombreusuario.github.io/nbdev_prueba/\n\n\n\nDocumentacion\n\n\n\n\n\n\n\n\nIntegración continua\nAl tener todo integrado facilitamos el trabajo del desarrollador, aprovechando el tiempo y librando de tareas que pueden resultar engorrosas y que lleva tiempo realizar.",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html#hacer-la-primera-edición",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html#hacer-la-primera-edición",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "Ya que hemos generado un repositorio y hemos modificado las configuraciones para tener la documentación alojada de forma automática vamos a hacer la primera edición a nuestro paquete.\n\n\nAntes de esto vamos a ejecutar el siguiente comando:\n$ nbdev_install_hooks\nEste comando instala ciertas extensiones en Jupyter Notebook y JupyterLab, las cuales nos permitirán limpiar los notebooks de metadatos que no son necesarios en los repositorios. Y arreglar ciertos elementos de los notebooks los cuales pueden llegar a causar conflictos cuando se hace uso de las acciones de git.\nEsto nos ayuda, pues es común que ciertos datos se modifiquen sin haber editado el notebook, esto sucede por el simple hecho de hacer su ejecución o abrir el notebook.\n\nnbdev_merge Nos ayuda a poner los notebooks de forma que al hacer el uso de acciones de pull merge, rebase o stash dentro de git, no modifiquen los notebooks y estos se puedan ejecutar entre los colaboradores del repositorio.\nnbdev_clean Los notebooks de Jupyter incluyen muchos metadatos que no se llevan bien con sistemas de control como git. Por tal motivo nbdev installa un “hook” el cual elimina estos metadatos o los reemplaza por versiones genéricas que no afectan la ejecución o visualizaciones dentro del notebook.\nnbdev_trust Un efecto secundario que se tiene al hacer uso de los notebooks de Jupyter es que estos no funcionan dentro de repositorios compartidos. La razón es que estos pueden ejecutar código HTML o código de JavaScript el cual puede llegar a contener código malicioso. Por tal motivo el comportamiento por defecto de los notebooks de Jupyter es preguntar si se puede confiar en el notebook cada vez que se abre esto puede ser una problemática en el flujo de trabajo por tal motivo se puede correr nbdev_trust para evitar que cada vez que se abre un notebook pregunte si es de confianza.\n\n\n\n\n\n\n\nCaution\n\n\n\nAdvertencia\nNo se debe de usar los hooks de nbdev dentro de un repositorio que no se confie.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nLos hooks de nbdev funcionan para cualquier repositorio, sin importar si se usa nbdev o no para generar un paquete o biblioteca.\n\n\n\n\n\n\nNbdev es muy modificable, esto se encuentra dentro del archivo settings.ini. Para crear el archivo se puede ejecutar nbdev_create_config.\n\n\n\nAbrimos el archivo nbs/00_core.ipynb, el cual se generó cuando ejecutamos nbdev_new. Dentro de éste se pueden observar las directrices más importantes para generar un documento que nos servirá para poder hacer tanto nuestro paquete, la documentación y su empaquetado.\nExpliquemos el comportamiento de las celdas que se encuentran dentro de este notebook.\nLa primera celda contiene\n# core\n\n&gt; Fill in a module description here\nAquí definimos que el módulo a crear se llamará core y la descripción del mismo. La celda contiene un encabezado H1 de Markdown # y una cita de Markdown donde se describe el módulo.\nLa segunda celda\n#| default_exp core\nEs una directriz en la cual se decide el módulo al cual el notebook exportará lo que se desee. Como se encuentra se exporta al módulo core.\nEn la siguiente celda\n#| hide\nfrom nbdev.showdoc import *\nLa directriz #| hide nos dice que esta celda no parecerá y tampoco la salida de la misma. Esto nos sirve para poder hacer ciertas pruebas pero que no se desean que sean exportadas ni que sean parte de la documentación.\nEn la celda siguiente\n#| export\ndef foo(): pass\n#| export exportará el contenido de la celda al módulo.\nLa última celda\n#| hide\nimport nbdev; nbdev.nbdev_export()\nusa la directriz #| hide para ocultar el código y la salida de la celda, lo que se ejecuta dentro de la celda es lo que permite exportar lo que se indicó dentro del notebook al módulo.\nVamos a modificar este notebook para hacer un módulo con funciones sencillas.\nAgregamos las siguientes celdas antes de la última celda en el notebook sin editar.\n#| export\ndef saludo():\n    \"\"\"Imprime Hola\"\"\"\n    print('Hola!')\n    return\nsaludo()\n#| export\ndef saludo_a(to):\n    \"\"\"Imprime hola a un nombre\"\"\"\n    print('Hola!', to)\n    \n    print('Espero que te encuentres bien')\n    return\nsaludo_a('Raul')\nshow_doc(saludo_a)\nLas celdas sin la directriz #| export nos pueden servir para probar las funcionalidades dentro del módulo o bien para ser parte de la documentación como ejemplos. En la celda se utiliza la función show_doc nos sirve para mostrar el uso de la documentación interna de la función saludo_a esta nos sirve para generar una documentación precisa.\nAhora podemos executar todo el notebook usando el boton ⏩ dentro de jupyterlab. Si todo funciona correctamente podemos generar la documentación, hacer pruebas y exportar a un módulo.",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html#ver-la-documentación",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html#ver-la-documentación",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "Para poder ver la documentación de forma local se ejecuta el siguiente comando desde el folder del repositorio\n$ nbdev_preview\nEl comando construye la documentación usando los notebooks que se encuentran dentro del directorio ‘nbs/’. Y genera un servicio de página web de forma local a la cual podemos acceder desde nuestro navegador.\nLa configuración se puede controlar desde el archivo settings.ini y por defecto toma a ‘nbs/index.ipynb’ como la pagina principal. A la izquierda nos muestra una columna donde podemos ir a la documentación del modulo “core”. Podremos observar que se encuentran las modificaciónes que se hicieron al módulo.\nSi se mantiene en servicio la página es posible ver los cambios que se hacen con cierto retraso.\n\n\n\nDocumentacion Modificada",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html#probar-el-módulo",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html#probar-el-módulo",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "Para probar que el todos los elementos del módulo funciona de forma correcta y si alguna modificación hecha no afecta en el desempeño de los componentes de los módulos en nuestro proyecto se utiliza el siguiente comando\n$ nbdev_test\nSi todo está correcto en la consola se desplegará\nSuccess.\nEn caso contrario se muestran los errores y se especifica los notebook en donde se encuentran.\nnbdev_test puede usarse para probar de manera individual los notebooks\n$ nbdev_test --path notebook.ipynb\nO para todo un directorio\n$ nbdev_test --path tests/",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html#generar-el-módulo",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html#generar-el-módulo",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "Para generar la documentación, desde la línea de comandos en el directorio de nuestro repositorio se llama el comando:\n$ nbdev_export\nEste comando genera nuestro módulo ‘core’ el cual se encontrará dentro del directorio ‘nbdev_prueba’. Si se desea se pueda abrir el archivo core.py el cual contiene una leyenda\n&gt;  # AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.\ninformando que el archivo fue autogenerado y que cualquier modificación debe de hacerse dentro del notebook nbs/00_core.ipynb.\nEn el archivo core.py podemos ver que se encuentran las funciones definidas dentro del notebook en las celdas con la directriz #| export.\nEl módulo generado forma parte de la nuestro proyecto.\nPor defecto al ejecutar nbdev_export se ejecuntan todos los notebooks del projecto. También se puede hacer sobre un notebook en específico.\nnbdev_export --path notebook.ipynb\no un directorio\nnbdev_export --path dir/\nEsto sólo sucedera si al principio del notebook se añade la directriz #| default_exp core al principio del notebook.",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html#añadir-los-cambios-en-github",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html#añadir-los-cambios-en-github",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "Para mantener el código usando Github limpiamos los notebooks con\n$ nbdev_clean\nEl comportamiento usual es limpiar todos los notebook que se encuentran en el directorio declarado en el archivo settings.ini en la parte de nbdev nbs_path = nbs pero también puede se puede limpiar un sólo notebook.\n$ nbdev_clean --fname notebook.ipynb\nTambién podemos ejecutar\n$ nbdev_readme \nel cual actualiza el Readme.md del repositorio.",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html#subir-los-cambios-al-repositorio-de-github",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html#subir-los-cambios-al-repositorio-de-github",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "Ya podemos hacer los ‘commits’ y ‘push’ a los cambios en el repositorio para que éstos se actualizen en Github. Nbdev nos da un comando para hacer todo para disminuir el tiempo para los cambios. Esto se puede hacer usando\n$ nbdev_prepare \nel cual exporta, prueba, limpia los notebooks y modifica el README del repositorio\n$ git add .\n$ git commit -m 'El primer commit con modificaciones' # Cambie el texto por el que se desee\n$ git push\n\n\nLa biblioteca se puede añadir a PIP o Anaconda en cualquiera de los casos es necesario tener una cuenta para hacer estas acciones.\nEn este caso se dan los pasos para hacer las instalación desde github usando pip install.\npip install \"Nombre\" @ git+\"URL del repositorio\"\nEn nuestro caso\npip install nbdev-prueba@git+https://github.com/\"Nombre_usuario_github\"/nbdev_prueba\nDe esta forma ya tenemos la biblioteca instalada dentro de nuestro ambiente de python. Para ver esto podemos abrir una terminal de python e importar el módulo core de nuestra biblioteca.\nfrom nbdev_prueba import core\ncore.saludo_a('Juan')\nY obtenemos como resultado\nHola! Juan\nEspero que te encuentres bien",
    "crumbs": [
      "Contenido",
      "Nbdev y sus usos"
    ]
  },
  {
    "objectID": "contenido/index.html",
    "href": "contenido/index.html",
    "title": "Curso Nbdev – Programación Literal",
    "section": "",
    "text": "📢 Contenido\n\n\n\n\n\n\n🎺 Presentacion concepto\n👣 Instalación de prerequisitos\n👣 Nbdev y herramientas\n🎺 Módulo Clusters\n\n\n\n\nMY_NAME  Profesor  CentroGeo 📧 MY_EMAIL (%20msalazar at centrogeo dot edu dot mx)",
    "crumbs": [
      "🏠 Home"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso Nbdev",
    "section": "",
    "text": "📑 Resumen del curso\nEnfoque: El objetivo de este curso es la enseñanza de nbdev para hacer desarrollo de software usando el concepto de programación literal (Literal Programing)\n¿Cómo ?: Se muestran brevemente las capacidades de nbdev y se hacen ejemplos para que todo el desarrollo de software se encuentre contenido en notebooks.\n\n\n🎯 Objetivos de aprendizaje\n\nComo hacer uso de la plataforma de Nbdev\nInstalación de cosas básicas\nGeneración de bibliotecas\nGeneración de documentación especializada\ntemas avanzados\n\n\n Contenido"
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html",
    "href": "contenido/Contenido/Tema1/nbdev_python.html",
    "title": "Curso NbdevIntroducción ",
    "section": "",
    "text": "Nbdev es un ambiente de programación para el desarrollo de software en Python el cual esta basado en el concepto de programación literal (literal programing) de Donald E. Knuth\n\nLiterate programming is a methodology that combines a programming language with a documentation language, thereby making programs more robust, more portable, more easily maintained, and arguably more fun to write than programs that are written only in a high-level language. The main idea is to treat a program as a piece of literature, addressed to human beings rather than to a computer.1\n\n\n\n\nNbdev es un ambiente de programación para el desarrollo de software en Python el cual esta basado en el concepto de programación literal (literal programing) de Donald E. Knuth\n\nProgramación literal es una metodología que combina un lenguaje de programación con un lenguaje de documentación, haciendo los programas más robustos, más portables, más fáciles de mantener y discutiblemente más divertidos de escribir que programas escritos en un lenguaje de programación de alto nivel. La idea principal es tratar a un programa como una pieza de literatura dirigido a un humano en vez de a una computadora. 2\n\n\n\n\nNbdev utiliza un jupyter notebooks para generar tanto el código de la biblioteca como la documentación de la misma.\n\n\n\nConstruir código a partir de Notebooks de Jupyter permitiendo que el desarrollo del software sea similar a contar una historia.\nGenerar documentación usando las propiedades de Markdown y Latex integradas en Jupyter y de fácil mantenimiento usando Quarto.\nPublicación de la documentación (A través de GitHub Pages)\nIntegración continua a través de GitHub Actions permitiendo generar pruebas para mantener y validar las utilidades del código.\nPublicas paquetes a PYPI y conda.\n\n\n\n\n\nGenerar pruebas del código esenciales para el mantenimiento del paquete.\n\nMantener notebooks limpios (Limpios de metadata y quedendonos sólo con la parte legible para los humanos).\nMuchos más!!!\n\n\n\n\n\nSe puede instalar a través de pip usando:\npip install nbdev\no instalar con conda:\nconda install -c fastai nbdev\nSi se utiliza conda para hacer uso de nbdev, es necesario que este instalado dentro del mismo ambiente de Python que se utiliza para hacer uso de Jupyter y del proyecto.\n\n\n\nEl desarrollo de nbdev esta ligado a su uso con herramientas software especificas. Por tal motivo la forma más sencilla de hacer uso de nbdev es utilizar dichas herramientas de software.\nHerramientas ligadas a nbdev:\n\nPython (Python o conda)\nManejador de paquetes de Python (pip o conda)\nJupyter Notebooks\nQuarto\nGithub\nnbdev\n\n\n\n\nLa idea central es poder hacer todo como una historia, hacer el desarrollo de una idea, pasarla a código, ver que funcione, hacer pruebas , exportar el código, hacer la documentacion, etc. Todo dentro de un mismo notebook.\nAl tener todo dentro de un mismo notebook nos permite que todo sea más simple.\n\nSe evita la repetición de código pues nombres de parámetros, constantes, typos, etc.\nSe simplifica la generación de ejemplos, pues si el ejemplo ya se encuentra dentro de un notebook el desarrollador no necesitará copiarlos y poner estos dentro de una documentación de forma manual.\nSe enriquecen los ejemplos y la documentación pues al hacer uso de los notebooks de Jupyter podemos hacer gráficas, imágenes, y ejemplos interactivos.\nPara los usuarios de la biblioteca o módulo que se desarrolla pueden reproducir de forma sencilla los ejemplos y resultados.\n\n\n\n\nEn sus origenes nbdev hacia uso de los notebook de Jupyter para hacer todo el desarrollo, a partir de su segunda versión se recomienda el uso de Quarto. Quarto nos permite usar los notebooks con la diferencia que a partir de un mismo notebook podemos generar distintos tipos de documentos como HTML, PDF, MS word, Markdown, presentaciones, etc. Uno de los formatos que podemos generar es el de un notebook de Jupyter, por tal motivo los desarrolladores de nbdev decidieron hacer uso de Quarto en vez de generar todo un nuevo ecosistema.\n\n\n\nUsando simples directrices dentro de los notebooks y sus celdas nos permite: * Crear la documentación * Exportar fragmentos de código para la creación de codigo fuente. * Ejecución de código para pruebas. * Visibilidad y comportamiento de celdas. * Manejo de variables internas. * etc.\nHaciendo uso de lo anterior nos permite generar tutoriales para mosrtrar el uso del desarrollo.",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#qué-es-nbdev",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#qué-es-nbdev",
    "title": "Curso NbdevIntroducción ",
    "section": "",
    "text": "Nbdev es un ambiente de programación para el desarrollo de software en Python el cual esta basado en el concepto de programación literal (literal programing) de Donald E. Knuth\n\nLiterate programming is a methodology that combines a programming language with a documentation language, thereby making programs more robust, more portable, more easily maintained, and arguably more fun to write than programs that are written only in a high-level language. The main idea is to treat a program as a piece of literature, addressed to human beings rather than to a computer.1",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#qué-es-nbdev-1",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#qué-es-nbdev-1",
    "title": "Curso NbdevIntroducción ",
    "section": "",
    "text": "Nbdev es un ambiente de programación para el desarrollo de software en Python el cual esta basado en el concepto de programación literal (literal programing) de Donald E. Knuth\n\nProgramación literal es una metodología que combina un lenguaje de programación con un lenguaje de documentación, haciendo los programas más robustos, más portables, más fáciles de mantener y discutiblemente más divertidos de escribir que programas escritos en un lenguaje de programación de alto nivel. La idea principal es tratar a un programa como una pieza de literatura dirigido a un humano en vez de a una computadora. 2",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#cuál-es-la-diferencia",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#cuál-es-la-diferencia",
    "title": "Curso NbdevIntroducción ",
    "section": "",
    "text": "Nbdev utiliza un jupyter notebooks para generar tanto el código de la biblioteca como la documentación de la misma.\n\n\n\nConstruir código a partir de Notebooks de Jupyter permitiendo que el desarrollo del software sea similar a contar una historia.\nGenerar documentación usando las propiedades de Markdown y Latex integradas en Jupyter y de fácil mantenimiento usando Quarto.\nPublicación de la documentación (A través de GitHub Pages)\nIntegración continua a través de GitHub Actions permitiendo generar pruebas para mantener y validar las utilidades del código.\nPublicas paquetes a PYPI y conda.\n\n\n\n\n\nGenerar pruebas del código esenciales para el mantenimiento del paquete.\n\nMantener notebooks limpios (Limpios de metadata y quedendonos sólo con la parte legible para los humanos).\nMuchos más!!!",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#instalación-rápida",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#instalación-rápida",
    "title": "Curso NbdevIntroducción ",
    "section": "",
    "text": "Se puede instalar a través de pip usando:\npip install nbdev\no instalar con conda:\nconda install -c fastai nbdev\nSi se utiliza conda para hacer uso de nbdev, es necesario que este instalado dentro del mismo ambiente de Python que se utiliza para hacer uso de Jupyter y del proyecto.",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#cómo-usar-nbdev",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#cómo-usar-nbdev",
    "title": "Curso NbdevIntroducción ",
    "section": "",
    "text": "El desarrollo de nbdev esta ligado a su uso con herramientas software especificas. Por tal motivo la forma más sencilla de hacer uso de nbdev es utilizar dichas herramientas de software.\nHerramientas ligadas a nbdev:\n\nPython (Python o conda)\nManejador de paquetes de Python (pip o conda)\nJupyter Notebooks\nQuarto\nGithub\nnbdev",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#cómo-funciona-nbdev",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#cómo-funciona-nbdev",
    "title": "Curso NbdevIntroducción ",
    "section": "",
    "text": "La idea central es poder hacer todo como una historia, hacer el desarrollo de una idea, pasarla a código, ver que funcione, hacer pruebas , exportar el código, hacer la documentacion, etc. Todo dentro de un mismo notebook.\nAl tener todo dentro de un mismo notebook nos permite que todo sea más simple.\n\nSe evita la repetición de código pues nombres de parámetros, constantes, typos, etc.\nSe simplifica la generación de ejemplos, pues si el ejemplo ya se encuentra dentro de un notebook el desarrollador no necesitará copiarlos y poner estos dentro de una documentación de forma manual.\nSe enriquecen los ejemplos y la documentación pues al hacer uso de los notebooks de Jupyter podemos hacer gráficas, imágenes, y ejemplos interactivos.\nPara los usuarios de la biblioteca o módulo que se desarrolla pueden reproducir de forma sencilla los ejemplos y resultados.",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#cómo-funciona-nbdev-en-su-segunda-versión",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#cómo-funciona-nbdev-en-su-segunda-versión",
    "title": "Curso NbdevIntroducción ",
    "section": "",
    "text": "En sus origenes nbdev hacia uso de los notebook de Jupyter para hacer todo el desarrollo, a partir de su segunda versión se recomienda el uso de Quarto. Quarto nos permite usar los notebooks con la diferencia que a partir de un mismo notebook podemos generar distintos tipos de documentos como HTML, PDF, MS word, Markdown, presentaciones, etc. Uno de los formatos que podemos generar es el de un notebook de Jupyter, por tal motivo los desarrolladores de nbdev decidieron hacer uso de Quarto en vez de generar todo un nuevo ecosistema.",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#cómo-funciona-nbdev-en-los-notebooks",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#cómo-funciona-nbdev-en-los-notebooks",
    "title": "Curso NbdevIntroducción ",
    "section": "",
    "text": "Usando simples directrices dentro de los notebooks y sus celdas nos permite: * Crear la documentación * Exportar fragmentos de código para la creación de codigo fuente. * Ejecución de código para pruebas. * Visibilidad y comportamiento de celdas. * Manejo de variables internas. * etc.\nHaciendo uso de lo anterior nos permite generar tutoriales para mosrtrar el uso del desarrollo.",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#footnotes",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#footnotes",
    "title": "Curso NbdevIntroducción ",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nFragmento del libro Literate Programming de Donald E. Knuth↩︎\nFragmento del libro Literate Programming de Donald E. Knuth↩︎",
    "crumbs": [
      "Contenido",
      "Presentación del concepto"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html",
    "title": "Curso Nbdev – Módulo con Clusters",
    "section": "",
    "text": "Un uso común en el mundo de los datos es el uso de algoritmos de agrupamiento o clusterización. A continuación vamos a tomar distintos algoritmos de clusterización y vamos a ponerlos todos dentro de un módulo. Este simple ejemplo aunque sencillo nos mostrará de forma más extensa el uso de nbdev.\nPrimero generamos nuestro repositorio como lo hicimos en el ejemplo anterior.\nUna vez con nuestro repositorio podemos iniciar nuestro repositorio de forma local y vamos a modificarlo para hacer el módulo de ejemplo.\n\n\nEn la sección anterior vimos como construir un ejemplo básico, en este vamos a generar un módulo que tenga una biblioteca simple donde contenga ejemplos básicos de distintos tipos de clusterizaciones.\nEntendamos la estructura que utiliza nbdev para generar nuestra nueva biblioteca, en el directorio nbs se encuentran los notebooks que vamos a modificar en nuestro ejemplo. al momento de creacion del repositorio una vez ejecutado el comando nbdev_new nos genera toda la estructura dentro de nuestro repositorio.\nSi no se hizo de la misma forma que como se describió anteriormente, esto se puede hacer de forma manual, se ejecuta el mismo comando y se rellenan los campos solicitados\n&gt; nbdev_new\n\n\n\n\n\n\nFigure 1: Salida nbdev_new\n\n\n\nEn el archivo settings.ini podemos ver las configuraciones, como ejemplo podemos ver que el archivo recien creado en el repositorio muestra los valores que se insertaron.\n\n\n\n\n\n\nFigure 2: contenido de settings.ini\n\n\n\nEn este archivo se puede modificar cosas como la licencia, la url de la documentación, donde se aloja la documentación, el autor, el nombre de la biblioteca, la ruta en donde se localizan los notebooks, etc.\nComo ya hemos visto para modificar algo en nuestra biblioteca es necesario hacerlo en los notebooks, con este propósito, nbdev generará los archivos correspondientes tanto de la documentación, como los archivos con el código que corresponden a los módulos de nuestra biblioteca.\nTambién nbdev generará el archivo README.md el cual sirve como portada en nuestro repositorio. Para hace modificaciones a este, se deben hacer desde el archivo nbs/index.ipynb el cual nos permitirá una vez terminada nuestra biblioteca dar instrucciones simples para su instalación así como la posibilidad de añadir links a la documentación de nuestra biblioteca. Se puede generar únicamente el archivo README.md ejecutando el comando nbdev_readme, una vez ejecutado se puede abrir el archivo y ver las modificaciones realizadas.\nnbdev_readme\nSi se desea ver desde github será necesario actualizar los cambios en el repositorio, para esto haremos un ejemplo desde la terminal sólo se muestra como ejemplo pues un curso completo de git queda fuera de los temas de este curso.\ngit add README.md\ngit commit -m \"Se modifica el README\"\ngit push\n\ngit add README.md añade el archivo que se modifico y que se desea que actualizar, o bien añadir el archivo si no se tiene dentro de nuesto conjunto de archivos vigilados.\ngit commit -m \"Se modifica el README\" se “comitea” es decir se añade a un registro de cambios de forma local los cambios hechos. -m es para añadir el comentario \"Se modifica el README\" a los cambios hechos, esto nos sirve como guía para ver qué cambios se han hecho y cúal fue la razón de nuestros cambios. Esto es muy útil cuando se buscan errores en el desarrollo y poder regresar al estado anterior.\ngit push Sube los cambios hechos a el servidor de git, en nuestro caso lo va a subir a github pues el es servicio que determinamos usar.\n\nPodemos ver las modificaciones en nuestro repositorio.\n\n\nOtros comandos importantes de git\n\ngit clone sirve poara clonar repositorios\ngit pull sirve para traer los cambios desde el servidor de git. El servidor depende de donde se tiene el servicio (github, gitlab o similares).\ngit config configura distintos valores de el repositorio.\ngit config –global user.name “Tu nombre” Cambia el valor de nombre de usuario de forma global.\ngit config –global user.email “tumail@example.com” Cambia el valor global del mail.\ngit init Crea un nuevo repositorio.\ngit commit -a “Comitea” todos los archivos añadidos anteriormente al repositorio.\ngit status Enlista los archivos que se han cambiado dentro y aquellos que todavia se necesitan añadir o “comitear”.\ngit checkout -b &lt;nombre_rama&gt; crea una nueva rama en el repositorio.\ngit checkout &lt;nombre_rama&gt;cambia a la rama .\ngit branch Enlista todas las ramas en el repositorio y en que rama te encuentras actualmente.\ngit branch -d &lt;nombre_rama&gt; Borra la rama .",
    "crumbs": [
      "Contenido",
      "Un ejemplo más entretenido Clusters"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html#entendiendo-un-poco-más",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html#entendiendo-un-poco-más",
    "title": "Curso Nbdev – Módulo con Clusters",
    "section": "",
    "text": "En la sección anterior vimos como construir un ejemplo básico, en este vamos a generar un módulo que tenga una biblioteca simple donde contenga ejemplos básicos de distintos tipos de clusterizaciones.\nEntendamos la estructura que utiliza nbdev para generar nuestra nueva biblioteca, en el directorio nbs se encuentran los notebooks que vamos a modificar en nuestro ejemplo. al momento de creacion del repositorio una vez ejecutado el comando nbdev_new nos genera toda la estructura dentro de nuestro repositorio.\nSi no se hizo de la misma forma que como se describió anteriormente, esto se puede hacer de forma manual, se ejecuta el mismo comando y se rellenan los campos solicitados\n&gt; nbdev_new\n\n\n\n\n\n\nFigure 1: Salida nbdev_new\n\n\n\nEn el archivo settings.ini podemos ver las configuraciones, como ejemplo podemos ver que el archivo recien creado en el repositorio muestra los valores que se insertaron.\n\n\n\n\n\n\nFigure 2: contenido de settings.ini\n\n\n\nEn este archivo se puede modificar cosas como la licencia, la url de la documentación, donde se aloja la documentación, el autor, el nombre de la biblioteca, la ruta en donde se localizan los notebooks, etc.\nComo ya hemos visto para modificar algo en nuestra biblioteca es necesario hacerlo en los notebooks, con este propósito, nbdev generará los archivos correspondientes tanto de la documentación, como los archivos con el código que corresponden a los módulos de nuestra biblioteca.\nTambién nbdev generará el archivo README.md el cual sirve como portada en nuestro repositorio. Para hace modificaciones a este, se deben hacer desde el archivo nbs/index.ipynb el cual nos permitirá una vez terminada nuestra biblioteca dar instrucciones simples para su instalación así como la posibilidad de añadir links a la documentación de nuestra biblioteca. Se puede generar únicamente el archivo README.md ejecutando el comando nbdev_readme, una vez ejecutado se puede abrir el archivo y ver las modificaciones realizadas.\nnbdev_readme\nSi se desea ver desde github será necesario actualizar los cambios en el repositorio, para esto haremos un ejemplo desde la terminal sólo se muestra como ejemplo pues un curso completo de git queda fuera de los temas de este curso.\ngit add README.md\ngit commit -m \"Se modifica el README\"\ngit push\n\ngit add README.md añade el archivo que se modifico y que se desea que actualizar, o bien añadir el archivo si no se tiene dentro de nuesto conjunto de archivos vigilados.\ngit commit -m \"Se modifica el README\" se “comitea” es decir se añade a un registro de cambios de forma local los cambios hechos. -m es para añadir el comentario \"Se modifica el README\" a los cambios hechos, esto nos sirve como guía para ver qué cambios se han hecho y cúal fue la razón de nuestros cambios. Esto es muy útil cuando se buscan errores en el desarrollo y poder regresar al estado anterior.\ngit push Sube los cambios hechos a el servidor de git, en nuestro caso lo va a subir a github pues el es servicio que determinamos usar.\n\nPodemos ver las modificaciones en nuestro repositorio.\n\n\nOtros comandos importantes de git\n\ngit clone sirve poara clonar repositorios\ngit pull sirve para traer los cambios desde el servidor de git. El servidor depende de donde se tiene el servicio (github, gitlab o similares).\ngit config configura distintos valores de el repositorio.\ngit config –global user.name “Tu nombre” Cambia el valor de nombre de usuario de forma global.\ngit config –global user.email “tumail@example.com” Cambia el valor global del mail.\ngit init Crea un nuevo repositorio.\ngit commit -a “Comitea” todos los archivos añadidos anteriormente al repositorio.\ngit status Enlista los archivos que se han cambiado dentro y aquellos que todavia se necesitan añadir o “comitear”.\ngit checkout -b &lt;nombre_rama&gt; crea una nueva rama en el repositorio.\ngit checkout &lt;nombre_rama&gt;cambia a la rama .\ngit branch Enlista todas las ramas en el repositorio y en que rama te encuentras actualmente.\ngit branch -d &lt;nombre_rama&gt; Borra la rama .",
    "crumbs": [
      "Contenido",
      "Un ejemplo más entretenido Clusters"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html#clase-clusters",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html#clase-clusters",
    "title": "Curso Nbdev – Módulo con Clusters",
    "section": "Clase clusters",
    "text": "Clase clusters\nVamos añadir una nueva clase a nuestro módulo, la cual llamaremos Clusters, esta clase nos sirve para generar clusters usando distintos algoritmos.\nclass Clusters:\n  \"\"\"\n  Clase para generar los clusters a partir de un objeto de la clase data_points\n  \n  Esta clase se utiliza para generar los distintos tipos de clusterizaciones, \n  se almacena los datos en una estructura de datos y se le añaden las respectivas \n  classes\n  \"\"\"\n    \n  def __init__(self, data_points_i, seed=1234):\n    if seed != None:\n      random.seed(seed)\n      self.data_structure =  data_points_i\n    \n  def KMeans(self, **kwargs):\n    \"\"\"\n    Se usa el algoritmo Kmeans para la obtencion de clusters, \n    las clases quedan almacenadas en .data_structure_classes_Kmeans.\n    Si se desea obtener el modelo se tiene que añadir \n    (ret_model = True) como parámetro.\n    \"\"\"\n    kmeans_c = KMeans(**kwargs)\n    classes_val = kmeans_c.fit_predict(self.data_structure.as_array())\n    self.data_structure.classes_Kmeans = classes_val\n    \n    if 'ret_model' in kwargs and kwargs['ret_model']==True :\n        return  kmeans_c\n        \n\n  def DBSCAN(self, **kwargs):\n    \"\"\"\n    Se DBSCAN para la obtencion de clusters, las clases quedan almacenadas\n    en .data_structure_classes_DBSCAN. Si se desea obtener el modelo se tiene\n    que añadir (ret_model = True) como parámetro.\n    \"\"\"\n    db = DBSCAN(**kwargs).fit(self.data_structure.as_array())\n    self.data_structure.classes_DBSCAN = db.labels_\n    if 'ret_model' in kwargs and kwargs['ret_model']==True :\n        return  db\n    \n    \n  def HDBSCAN(self, **kwargs):\n    \"\"\"\n    Se HDBSCAN para la obtencion de clusters, las clases quedan almacenadas\n    en .data_structure_classes_HDBSCAN. Si se desea obtener el modelo se tiene\n    que añadir (ret_model = True) como parámetro.\n    \"\"\"\n    hdb = HDBSCAN(**kwargs).fit(self.data_structure.as_array())\n    self.data_structure.classes_HDBSCAN = hdb.labels_\n    if 'ret_model' in kwargs and kwargs['ret_model']==True : \n      return  hdb\n        \n\n  def OPTICS(self, **kwargs):\n    \"\"\"\n    Se usa el algoritmo OPTICS para la obtencion de clusters, \n    las clases quedan almacenadas en .data_structure_classes_OPTICS.\n    Si se desea obtener el modelo se tiene que añadir \n    (ret_model = True) como parámetro.\n    \"\"\"\n    optics=  OPTICS(**kwargs).fit(self.data_structure.as_array())\n    self.data_structure.classes_OPTICS = optics.labels_\n    \n    if 'ret_model' in kwargs and kwargs['ret_model']==True :\n        return  optics\nPara exportar la clase al módulo es necesario añadir la directriz #| export al inicio de la celda. Adicionalmente añadimos pruebas simples usando los datos que ya se generaron.\ncluster_all  = Clusters(datos_simples)\ncluster_all.DBSCAN()\ncluster_all.KMeans()\ncluster_all.HDBSCAN()\ncluster_all.OPTICS()\nComo estas celdas nos sirven de pruebas vamos a añadir la directriz #| hide para evitar que estas sean parte de la documentación. Ahora podemos añadir ejemplos del uso de la clase cluster e incluso añadir como se usan los métodos.",
    "crumbs": [
      "Contenido",
      "Un ejemplo más entretenido Clusters"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html#documentación",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html#documentación",
    "title": "Curso Nbdev – Módulo con Clusters",
    "section": "Documentación",
    "text": "Documentación\nPara generar la documentación se hace usando el comando\nnbdev_docs\nEn este caso, en la terminal podemos observar lo que se muestra en la imagen Figure 5, como se observa en el directorio _docs se encuentra un archivo html que puede abrirse usando un navegador y se puede ver la documentación y se puede ver que sólo muestra el ‘docstring’ generado por las clase como en la figura Figure 3 y el respectivo para la clase Clusters.\n\n\n\n\n\n\nFigure 5: Generación documentación\n\n\n\nPara mostrar un poco más lo que hace nuestra clase simple añadimos las siguientes celdas\nshow_doc(Clusters.KMeans)\nshow_doc(Clusters.DBSCAN)\nshow_doc(Clusters.HDBSCAN)\nshow_doc(Clusters.OPTICS)\nEstas mostrarán lo que se haya puesto dentro de los ‘docstrings’ de los métodos en la clase Cluster.\nTambién podemos generar la documentación y hacer una previsualización haciendo uso del comando\nnbdev_preview\nlo cual nos mostrará\n\n\n\n\n\n\nFigure 6: Muestra la documentación\n\n\n\nllevándonos a la documentación de forma local.\n\n\n\n\n\n\nActividad\n\n\n\n\n\nMuestre los métodos para la clase data_points en la documentación",
    "crumbs": [
      "Contenido",
      "Un ejemplo más entretenido Clusters"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html#mas-documentación",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html#mas-documentación",
    "title": "Curso Nbdev – Módulo con Clusters",
    "section": "Mas documentación",
    "text": "Mas documentación\nPodemos hacer uso de las facilidades de los jupyter notebooks para generar ejemplos y tutoriales, para esto vamos hacer dentro del mismo notebook.\nCreamos un conjunto de datos usando los distintos métodos en las clases que ya hicimos.\ndatos_simples_3 = data_points(500, min_x = 0.6, min_y= 0.6, max_x= 1.0, max_y= 1.0 )\ndatos_simples_2 = data_points(500, min_x = 0.0, min_y= 0.6, max_x= 0.4, max_y= 1.0 )\ndatos_simples_1 = data_points(500, min_x = 0.6, min_y= 0.0, max_x= 1.0, max_y= 0.4 )\ndatos_simples_0 = data_points(500, min_x = 0.0, min_y= 0.0, max_x= 0.4, max_y= 0.4 )\nUnimos todos los puntos con el método add_points de la clase data_points.\ndatos_simples_0.add_points(datos_simples_1)\ndatos_simples_0.add_points(datos_simples_2)\ndatos_simples_0.add_points(datos_simples_3)\nVeamos los puntos dentro de nuestra estructura.\ndatos_simples_0.get_Multypoint()\nAhora inicialicemos nuestro objeto Clusters\ncluster_all  = Clusters(datos_simples_0)\nY ahora podemos hacer uso de los algoritmos usando los métodos de las distintas las clusterizaciones.\ncluster_all.OPTICS()\ncluster_all.HDBSCAN()\ncluster_all.DBSCAN(eps=0.1, min_samples=10)\ncluster_all.KMeans()\nY visualizemos las clusterizaciones\nfig, ax = plt.subplots(1,1, figsize=(6,6))\nplt.scatter(\n  cluster_all.data_structure.get_X(),\n  cluster_all.data_structure.get_Y(),\n  c = cluster_all.data_structure.classes_Kmeans\n)\nfig, ax = plt.subplots(1,1, figsize=(6,6))\nplt.scatter(\n  cluster_all.data_structure.get_X(),\n  cluster_all.data_structure.get_Y(),\n  c = cluster_all.data_structure.classes_DBSCAN\n)\nfig, ax = plt.subplots(1,1, figsize=(6,6))\nplt.scatter(\n  cluster_all.data_structure.get_X(),\n  cluster_all.data_structure.get_Y(),\n  c = cluster_all.data_structure.classes_HDBSCAN\n)\nfig, ax = plt.subplots(1,1, figsize=(6,6))\nplt.scatter(\n  cluster_all.data_structure.get_X(),\n  cluster_all.data_structure.get_Y(),\n  c = cluster_all.data_structure.classes_OPTICS\n)\nSi se ejecuta nbdev_preview o nbdev_docs en la documentación mostrará el ejemplo dentro de la misma.\nAhora para preparar verificar que todo esta bien ejecutamos\nnbdev_prepare\nLo cual mostrará  si no hay ningun problema. En el fondo lo que hace nbdev_prepare preprocesar los archivos dentro de nbs y generar los",
    "crumbs": [
      "Contenido",
      "Un ejemplo más entretenido Clusters"
    ]
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html#entendiendo-github-actions.",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html#entendiendo-github-actions.",
    "title": "Curso Nbdev – Módulo con Clusters",
    "section": "Entendiendo github-actions.",
    "text": "Entendiendo github-actions.\nLas acciones de Github actions nos permiten realizar acciones automatizadas dentro de nuestro directorio de Github, en nuestro caso dichas acciones se encuentran dentro de los archivos que se encuentran en el directorio .github dentro del directorio workflows los cuales son deploy.yaml y test.yaml. Estos dos archivos controlan los dos flujos de trabajo que se realizan dentro de github. Vamos a modificarlos y explicar un poco que hacen cada uno.\nEl archivo deploy es el que utilizamos para generar la documentación, vamos a sustituir el contenido del archivo con el que se encuentra en la celda siguiente:\n\nArchivo deploy.yaml\nname: Deploy to GitHub Pages\non:  [workflow_dispatch, pull_request, push] \npermissions:\n  contents: write\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps: \n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n      - name: Install Dependencies and create documentation \n        shell: bash\n        run: |\n          python -m pip install --upgrade pip\n          pip install -Uq git+https://github.com/fastai/ghapi.git # you need this for enabling pages\n          pip install -Uq git+https://github.com/fastai/fastcore.git\n          pip install -Uq git+https://github.com/fastai/execnb.git\n          pip install -U git+https://github.com/fastai/nbdev.git\n          wget -q $(curl https://latest.fast.ai/pre/quarto-dev/quarto-cli/linux-amd64.deb)\n          sudo dpkg -i quarto*.deb\n          pip install -Uq matplotlib\n          pip install -Uq setuptools\n          pip install -Uq scikit-learn\n          pip install -Uq shapely\n          nbdev_docs\n#          pip install -e \".[dev]\"\n         \n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v4\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          force_orphan: true\n          publish_dir: ./_docs\n          # The following lines assign commit authorship to the official GH-Actions bot for deploys to `gh-pages` branch.\n          # You can swap them out with your own user credentials.\n          user_name: github-actions[bot]\n          user_email: 41898282+github-actions[bot]@users.noreply.github.com\nExpliquemos a grandes rasgos lo que esta haciendo este archivo. Las primeras lineas le dan nombre a la acción y cuando se realiza esta. En este caso llamamos a la acción ‘Deploy to GitHub Pages’ y la acción será realizada cuando se solicite de forma manual (‘workflow_dispatch’) cuando se haga una petición pull (‘pull_request’) o bien quando se realize un push.\nname: Deploy to GitHub Pages\non:  [workflow_dispatch, pull_request, push] \nEl trabajo que va a realizar se denomina ‘deploy’ el cual utilizará una máquina virtual con la versión más reciente de ubuntu (‘ubuntu-latest’).\nEn las siguientes lineas estamos dando permiso a la maquina virtual de poder escribir dentro de nuestro repositorio.\npermissions:\n  contents: write\nDespues el trabajo consiste en los siguientes pasos:\n- uses: actions/checkout@v3\n- uses: actions/setup-python@v4\nUtiliza las acciones actions/checkout@v3 y actions/setup-python@v4 que son acciones que tenemos estandarizadas dentro de github actions. Las cuales hace un check out del repositorio dentro de la maquina virtual para realizar el trabajo. actions/setup-python@v4 instala python dentro de la maquina virtual.\nEl siguiente paso lo llamamo ‘Install Dependencies and create documentation’ aquí podemos ver que hacemos un conjunto de acciones que hicimos con anterioridad cuando instalamos las cosas necesarias para hacer uso de Nbdev, Git, Quarto, etc.\n- name: Install Dependencies and create documentation \n    shell: bash\n    run: |\n    python -m pip install --upgrade pip\n    pip install -Uq git+https://github.com/fastai/ghapi.git # you need this for enabling pages\n    pip install -Uq git+https://github.com/fastai/fastcore.git\n    pip install -Uq git+https://github.com/fastai/execnb.git\n    pip install -U git+https://github.com/fastai/nbdev.git\n    wget -q $(curl https://latest.fast.ai/pre/quarto-dev/quarto-cli/linux-amd64.deb)\n    sudo dpkg -i quarto*.deb\n    pip install -Uq matplotlib\n    pip install -Uq setuptools\n    pip install -Uq scikit-learn\n    pip install -Uq shapely\n    nbdev_docs\nPongamos especial atención en las últimas líneas, aquí instalamos las dependencias que se utilizaron en hacer nuestra biblioteca y son necesarias para que los notebooks que hicimos puedan correr. Una vez instaladas las dependencias podemos generar la documentación con ‘nbdev_docs’.\nComo en la máquina virtual ya generamos nuestra documentación ahora vamos a ponerla dentro de un nuevo ‘branch’, por eso le tenemos que dar permiso para escribir, dentro del repositorio y usar ese ‘branch’ para publicar la documentación usando el siguiente paso:\n- name: Deploy to GitHub Pages\n    uses: peaceiris/actions-gh-pages@v4\n    with:\n      github_token: ${{ secrets.GITHUB_TOKEN }}\n      force_orphan: true\n      publish_dir: ./_docs\n      # The following lines assign commit authorship to the official GH-Actions bot for deploys to `gh-pages` branch.\n      # You can swap them out with your own user credentials.\n      user_name: github-actions[bot]\n      user_email: 41898282+github-actions[bot]@users.noreply.github.com\nEsto usa las acciones descritas en peaceiris/actions-gh-pages@v4 las cuales ya estan automatizadas para generar un nuevo branch con nombre ‘gh-pages’ y añadir el contenido de la documentación dentro de el branch. Lo que se añade dentro del branch es lo que se encuentra dentro del directorio ’./_docs’. ‘github_token’ nos permite autenticar el trabajo realizado por el flujo de trabajo. Los parámetros de ‘user_name’ y ‘user_email’ permiten avisar que acciones fueron realizadas por el script ‘peaceiris/actions-gh-pages@v4’ y las cuales aparecerán que fueron realizadas por github-pages bot. Estas acciones nos enviaran un mail con el resultado del trabajo realizado, es decir si este fue exitoso o no.\n\n\nArchivo test.yaml\nEn el caso de las pruebas estas se hacen en las acciones en el archivo ‘test.yaml’ y vamos a remplazar su contenido por el código siguiente:\n\nname: Test CI\non:  [workflow_dispatch, pull_request, push]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n      - name: Install Nbdev Dependencies\n        shell: bash\n        run: |\n          python -m pip install --upgrade pip\n          pip install -Uq git+https://github.com/fastai/ghapi.git # you need this for enabling pages\n          pip install -Uq git+https://github.com/fastai/fastcore.git\n          pip install -Uq git+https://github.com/fastai/execnb.git\n          pip install -U git+https://github.com/fastai/nbdev.git\n      - name: Install package dependencies\n        shell: bash\n        run: |\n          python -m pip install -Uq matplotlib\n          python -m pip install -Uq setuptools\n          python -m pip install -Uq scikit-learn\n          python -m pip install -Uq shapely\n\n      - name: Test the package\n        shell: bash\n        run: |\n          echo \"Check we are starting with clean git checkout\"\n          if [[ `git status --porcelain -uno` ]]; then\n            git diff\n            echo \"git status is not clean\"\n            false\n          fi\n          echo \"Trying to strip out notebooks\"\n          nbdev_clean\n          echo \"Check that strip out was unnecessary\"\n          git status -s # display the status to see which nbs need cleaning up\n          if [[ `git status --porcelain -uno` ]]; then\n            git status -uno\n            echo -e \"!!! Detected unstripped out notebooks\\n!!!Remember to run nbdev_install_hooks\"\n            echo -e \"This error can also happen if you are using an older version of nbdev relative to what is in CI.  Please try to upgrade nbdev with the command `pip install -U nbdev`\"\n            false\n          fi\n          nbdev_export\n          if [[ `git status --porcelain -uno` ]]; then\n            echo \"::error::Notebooks and library are not in sync.  Please run nbdev_export.\"\n            git status -uno\n            git diff\n            exit 1;\n          fi\n          if [ ! $SKIP_TEST ]; then\n            nbdev_test --flags \"$FLAGS\"\n          fi\n      \nDe forma similar el nombre del trabajo es ‘Test CI’ los trabajos se se realizan cuando se hace una petición de forma manual o se hace un pull o un push.\nSe corre en una máquina virtual con ubuntu ‘runs-on: ubuntu-latest’ y hace un checkout, se instala python y nbdev junto con sus dependencias.\nEn el siguiente paso se instalan las dependencias de la biblioteca en la maquina virtual.\n- name: Install package dependencies\n    shell: bash\n    run: |\n        python -m pip install -Uq matplotlib\n        python -m pip install -Uq setuptools\n        python -m pip install -Uq scikit-learn\n        python -m pip install -Uq shapely\n    \nY en lo que resta del código verifica si estas cosas y hace las pruebas usando nbdev_test dentro de la maquina virtual\n\ngit se verifica el contenido de la versión del repositorio que se encuentra en la máquina virtual\nVerifica que los notebooks no tengan cosas inecesarias, si no es así marca error\nConstruye la biblioteca dentro de la máquina virtual usando ‘nbdev_export’\nHace las pruebas usando ‘nbdev_test’\n\nname: Test the package\n    shell: bash\n    run: |\n        echo \"Check we are starting with clean git checkout\"\n        if [[ `git status --porcelain -uno` ]]; then\n        git diff\n        echo \"git status is not clean\"\n        false\n        fi\n        echo \"Trying to strip out notebooks\"\n        nbdev_clean\n        echo \"Check that strip out was unnecessary\"\n        git status -s # display the status to see which nbs need cleaning up\n        if [[ `git status --porcelain -uno` ]]; then\n        git status -uno\n        echo -e \"!!! Detected unstripped out notebooks\\n!!!Remember to run nbdev_install_hooks\"\n        echo -e \"This error can also happen if you are using an older version of nbdev relative to what is in CI.  Please try to upgrade nbdev with the command `pip install -U nbdev`\"\n        false\n        fi\n        nbdev_export\n        if [[ `git status --porcelain -uno` ]]; then\n        echo \"::error::Notebooks and library are not in sync.  Please run nbdev_export.\"\n        git status -uno\n        git diff\n        exit 1;\n        fi\n        if [ ! $SKIP_TEST ]; then\n        nbdev_test --flags \"$FLAGS\"\n        fi\nComo se observa, los pasos anteriores son los que ya hemos desde la instalación y la construcción de la biblioteca.\nCon los archivos que hemos modificado hemos dado las instrucciónes para que estas acciones se desarrollen en máquinas virtuales en servidores de github.\nSi todo se encuentra en orden podemos salvar los archivos, hacer un commit, y hacer un push. Como las acciones se ejecuntan cuando se hace un push podemos ver en las acciones de github e ir a la página de github para verificar que el flujo de trabajo funciona de forma adecuada. En el menu Actions del repositrio.\n\n\n\n\n\n\nFigure 7: Menu github actions\n\n\n\nEn este menú veremos las acciones que se llevan a cabo del lado izquierdo en nuestro caso:\n\nDeploy to Github Pages\nTest CI\npages-build-deployment (ejecutado al hacer el branch ‘gh-pages’)\n\nEn el centro una lista con los commits realizado y el resultado de las acciones que se llevaron acabo y si estas tuvieron éxito (✅) o no (❌).\n\n\n\n\n\n\nFigure 8: Woorkflows Actions\n\n\n\nPara habilitar nuestra página de documentación se tienen que seguir los mismos pasoes que vimos anteriormente y se selecciona el branch de ‘gh-pages’ para habilitar la documentación.",
    "crumbs": [
      "Contenido",
      "Un ejemplo más entretenido Clusters"
    ]
  }
]