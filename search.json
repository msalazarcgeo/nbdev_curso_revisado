[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso Nbdev",
    "section": "",
    "text": "üéØ Objetivos de aprendizaje\n\nComo hacer uso de la plataforma de Nbdev\nInstalaci√≥n de cosas b√°sicas\nGeneraci√≥n de bibliotecas\nGeneraci√≥n de documentaci√≥n especializada\ntemas avanzados\n\n\n Contenido"
  },
  {
    "objectID": "contenido/index.html",
    "href": "contenido/index.html",
    "title": "Curso Nbdev ‚Äì Programaci√≥n Literal",
    "section": "",
    "text": "MY_NAME  Profesor  CentroGeo üìß MY_EMAIL (%20msalazar at centrogeo dot edu dot mx)"
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#qu√©-es-nbdev",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#qu√©-es-nbdev",
    "title": "Curso NbdevIntroducci√≥n ",
    "section": "¬ø Qu√© es Nbdev ?",
    "text": "¬ø Qu√© es Nbdev ?\nNbdev es un ambiente de programaci√≥n para el desarrollo de software en Python el cual esta basado en el concepto de programaci√≥n literal (literal programing) de Donald E. Knuth\n\nLiterate programming is a methodology that combines a programming language with a documentation language, thereby making programs more robust, more portable, more easily maintained, and arguably more fun to write than programs that are written only in a high-level language. The main idea is to treat a program as a piece of literature, addressed to human beings rather than to a computer.1\n\nFragmento del libro Literate Programming de Donald E. Knuth"
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#qu√©-es-nbdev-1",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#qu√©-es-nbdev-1",
    "title": "Curso NbdevIntroducci√≥n ",
    "section": "¬ø Qu√© es Nbdev ?",
    "text": "¬ø Qu√© es Nbdev ?\nNbdev es un ambiente de programaci√≥n para el desarrollo de software en Python el cual esta basado en el concepto de programaci√≥n literal (literal programing) de Donald E. Knuth\n\nProgramaci√≥n literal es una metodolog√≠a que combina un lenguaje de programaci√≥n con un lenguaje de documentaci√≥n, haciendo los programas m√°s robustos, m√°s portables, m√°s f√°ciles de mantener y discutiblemente m√°s divertidos de escribir que programas escritos en un lenguaje de programaci√≥n de alto nivel. La idea principal es tratar a un programa como una pieza de literatura dirigido a un humano en vez de a una computadora. 1\n\nFragmento del libro Literate Programming de Donald E. Knuth"
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#cu√°l-es-la-diferencia",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#cu√°l-es-la-diferencia",
    "title": "Curso NbdevIntroducci√≥n ",
    "section": "¬ø Cu√°l es la diferencia ?",
    "text": "¬ø Cu√°l es la diferencia ?\nNbdev utiliza un jupyter notebooks para generar tanto el c√≥digo de la biblioteca como la documentaci√≥n de la misma.\nPermite\n\nConstruir c√≥digo a partir de Notebooks de Jupyter permitiendo que el desarrollo del software sea similar a contar una historia.\nGenerar documentaci√≥n usando las propiedades de Markdown y Latex integradas en Jupyter y de f√°cil mantenimiento usando Quarto.\nPublicaci√≥n de la documentaci√≥n (A trav√©s de GitHub Pages)\nIntegraci√≥n continua a trav√©s de GitHub Actions permitiendo generar pruebas para mantener y validar las utilidades del c√≥digo.\nPublicas paquetes a PYPI y conda.\n\nAdicionalmente\n\nGenerar pruebas del c√≥digo esenciales para el mantenimiento del paquete.\n\nMantener notebooks limpios (Limpios de metadata y quedendonos s√≥lo con la parte legible para los humanos).\nMuchos m√°s!!!"
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#instalaci√≥n-r√°pida",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#instalaci√≥n-r√°pida",
    "title": "Curso NbdevIntroducci√≥n ",
    "section": "Instalaci√≥n r√°pida",
    "text": "Instalaci√≥n r√°pida\nSe puede instalar a trav√©s de pip usando:\npip install nbdev\no instalar con conda:\nconda install -c fastai nbdev\nSi se utiliza conda para hacer uso de nbdev, es necesario que este instalado dentro del mismo ambiente de Python que se utiliza para hacer uso de Jupyter y del proyecto."
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#c√≥mo-usar-nbdev",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#c√≥mo-usar-nbdev",
    "title": "Curso NbdevIntroducci√≥n ",
    "section": "¬ø C√≥mo usar nbdev ?",
    "text": "¬ø C√≥mo usar nbdev ?\nEl desarrollo de nbdev esta ligado a su uso con herramientas software especificas. Por tal motivo la forma m√°s sencilla de hacer uso de nbdev es utilizar dichas herramientas de software.\nHerramientas ligadas a nbdev:\n\nPython (Python o conda)\nManejador de paquetes de Python (pip o conda)\nJupyter Notebooks\nQuarto\nGithub\nnbdev"
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#c√≥mo-funciona-nbdev",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#c√≥mo-funciona-nbdev",
    "title": "Curso NbdevIntroducci√≥n ",
    "section": "¬ø C√≥mo funciona nbdev ?",
    "text": "¬ø C√≥mo funciona nbdev ?\nLa idea central es poder hacer todo como una historia, hacer el desarrollo de una idea, pasarla a c√≥digo, ver que funcione, hacer pruebas , exportar el c√≥digo, hacer la documentacion, etc. Todo dentro de un mismo notebook.\nAl tener todo dentro de un mismo notebook nos permite que todo sea m√°s simple.\n\nSe evita la repetici√≥n de c√≥digo pues nombres de par√°metros, constantes, typos, etc.\nSe simplifica la generaci√≥n de ejemplos, pues si el ejemplo ya se encuentra dentro de un notebook el desarrollador no necesitar√° copiarlos y poner estos dentro de una documentaci√≥n de forma manual.\nSe enriquecen los ejemplos y la documentaci√≥n pues al hacer uso de los notebooks de Jupyter podemos hacer gr√°ficas, im√°genes, y ejemplos interactivos.\nPara los usuarios de la biblioteca o m√≥dulo que se desarrolla pueden reproducir de forma sencilla los ejemplos y resultados."
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#c√≥mo-funciona-nbdev-en-su-segunda-versi√≥n",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#c√≥mo-funciona-nbdev-en-su-segunda-versi√≥n",
    "title": "Curso NbdevIntroducci√≥n ",
    "section": "¬ø C√≥mo funciona nbdev en su segunda versi√≥n ?",
    "text": "¬ø C√≥mo funciona nbdev en su segunda versi√≥n ?\nEn sus origenes nbdev hacia uso de los notebook de Jupyter para hacer todo el desarrollo, a partir de su segunda versi√≥n se recomienda el uso de Quarto. Quarto nos permite usar los notebooks con la diferencia que a partir de un mismo notebook podemos generar distintos tipos de documentos como HTML, PDF, MS word, Markdown, presentaciones, etc. Uno de los formatos que podemos generar es el de un notebook de Jupyter, por tal motivo los desarrolladores de nbdev decidieron hacer uso de Quarto en vez de generar todo un nuevo ecosistema."
  },
  {
    "objectID": "contenido/Contenido/Tema1/nbdev_python.html#c√≥mo-funciona-nbdev-en-los-notebooks",
    "href": "contenido/Contenido/Tema1/nbdev_python.html#c√≥mo-funciona-nbdev-en-los-notebooks",
    "title": "Curso NbdevIntroducci√≥n ",
    "section": "¬ø C√≥mo funciona nbdev en los notebooks ?",
    "text": "¬ø C√≥mo funciona nbdev en los notebooks ?\nUsando simples directrices dentro de los notebooks y sus celdas nos permite: * Crear la documentaci√≥n * Exportar fragmentos de c√≥digo para la creaci√≥n de codigo fuente. * Ejecuci√≥n de c√≥digo para pruebas. * Visibilidad y comportamiento de celdas. * Manejo de variables internas. * etc.\nHaciendo uso de lo anterior nos permite generar tutoriales para mosrtrar el uso del desarrollo.\n\n\n\nCurso Nbdev ‚Äì Introducci√≥n"
  },
  {
    "objectID": "contenido/Contenido/Tema2/Instalacion_rapida.html",
    "href": "contenido/Contenido/Tema2/Instalacion_rapida.html",
    "title": "Curso Nbdev Introducci√≥n",
    "section": "",
    "text": "Para hacer uso de nbdev es necesario los siguientes softwares:\n\nPython (Python o conda)\nJupyter Notebooks\nQuarto\nGithub\nnbdev\n\nA continuaci√≥n se da una breve explicaci√≥n de cada uno de estos y como lo utilizamos.\n\n\nAnaconda es una empresa la cual desarrollo un manejador de ambientes virtuales con un manejador de paquetes (conda), √©ste nos permite la creaci√≥n de ambientes virtuales. Dentro de dichos ambientes se puede hacer un manejo eficiente de los diferentes softwares instalados dentro del ambiente virtual y las dependencias de los mismos. Al tener un manejo eficiente de las paqueterias y las dependencias dentro de este se hace m√°s f√°cil la creaci√≥n de ambientes de desarrollo.\nDe esta forma algo instalado dentro de un ambiente virtual no afectara a las distintas paqueterias que se encuentran fuera del ambiente virtual. Lo cual nos permite tener tener aislado un ambiente de desarrollo con respecto al sistema operativo u otro ambiente de desarrollo.\n\n\nPara la instalaci√≥n de conda lo m√°s sencillo es seguir el este manual aqu√≠ s√≥lo se hace un esbozo de la instalaci√≥n.\n\nBajar el instalador:\n\nAnaconda para windows.\n\nVerificar que se ha bajano correctamente (ver ).\nHacer doble click en el archivo .exe (similar a Anaconda3-######-Windows-x86_64.exe). Para la instalaci√≥n en Linux o Mac se debe de bajar el archivo Anaconda3-####-Linux-###.sh o bien el Anaconda3-####-MACOSX-###.sh y ejecutar el archivo usando la terminal.\nSeguir las instrucciones en la pantalla en caso de windows. Y seguir la instrucciones que apareceran en caso del uso de la terminal.\nPara probar la instalaci√≥n abra la terminal de windows (cmd) o el anaconda prompt y corra el comando conda list. Una lista de paquetes aparecera si se instal√≥ de forma correcta.\n\n\n\n\nPara generar un ambiente virtual usando anaconda se puede hacer a trav√©s de la terminal. En caso de windows se puede hacer llamando a Anaconda Prompt.\nDentro de la terminal se puede observar que antes del s√≠mbolo del sistema aparece la leyenda (base) esta no indica que estamos usando el ambiente virtual base.\nPara crear un nuevo ambiente virtual se ejecuta la siguiente linea en la linea de comandos.\nconda create -n desarrollo\nEste comando crea un nuevo ambiente virtual llamano desarrollo. Se puede especificar la versi√≥n de python a instalar dentro del ambiente virtual. Tambi√©n es posible instalar otros lenguajes de programaci√≥n dentro del ambiente virtual cono son R o Julia.\nPara entrar al ambiente virtual la forma de hacerlo es ejecutar\nconda activate desarrollo\nAl ejecutar el comando se puede observar que la leyenda (base) fue sustituida por la leyenda (desarrollo) lo cual nos indica que hemos activado nuestro ambiente virtual.\n\n\n\nDentro de nuestro ambiente virtual podemos instalar las distintas bibliotecas y paquetes que sean necesarios. Por defecto Anaconda tiene un canal para poner a la disposici√≥n de la comunidad, que utiliza conda, muchos paquetes. Anaconda es la encargada de verificar que el el desarrollo de dichos paquetes sean de acuerdo a las mismas reglas establecidas por Anaconda. De la misma forma hay distintos canales los cuales tiene paquetes que estan de acuerdo a las reglas establecidas por cada canal. Los distintos canales tienen distintos objetivos por ejemplo bioconda contiene las paqueterias desarrolladas relacionadas con desarrollos biom√©dicos.\nOtro canal muy utilizado es conda-forge, el cual contiene paquetes desarrollados por una extensa comunidad. Por facilidad en este curso utilizaremos el canal conda-forge pues tiene la mayoria de las paqueterias necesarias y se encuentran muchas versiones de los mismos.\n\n\n\nPara instalar un paquete dentro del ambiente virtual es necesario activar el ambiente. Ya dentro de este para hacer la instalaci√≥n de los distintos paquetes de python tenemos dos formas distintas PIP o conda. PIP es el manejador de paquetes usado por python por defecto si se a trabajado anteriormente con Python lo m√°s seguro es estar familiarizado con su uso.\nconda es el manejador de paquetes del ambiente virtual y nos permite tanto hacer instalar paqueter√≠a de python y otras. Por ejemplo podemos instalar R o Julia haciendo uso de conda.\nComo ejemplo para instalar numpy usando conda y el canal conda-forge executamos\n(desarrollo) $ conda install -c conda-forge numpy\n\n\n\n\nJupyter es un conjunto de softwares que nos permite hacer uso de multiples herramientas, una de sus principales herramientas es el uso de noteboooks los cuales son documentos donde podemos escribir texto plano y hacer ejecuci√≥n de c√≥digo. Para que los documentos finales tengan una mayor riqueza se utiliza Markdown y adicionalmente se puede hacer uso de LaTex para escribir f√≥rmulas matem√°ticas.\nA trav√©s del uso de JupyterLab es posible hacer desarrollo de software de forma interactiva usando notebooks, c√≥digo e informaci√≥n. Esto ayuda al desarrollador a generar un archivo que tiene todo el contexto del desarrollo y entender la forma en la cual el software fue desarrollado, por que se tomaron ciertas decisiones en la creaci√≥n del c√≥digo. Esto es particularmente √∫til en el an√°lisis exploratorio de datos, en la ciencia de d√°tos y en el desarrollo de la inteligencia artificial.\nEl uso de los notebooks ha sido usado principalmente para hacer an√°lisis exploratorios y esto gener√≥ la necesidad de poder generar gr√°ficos dentro de los notebooks lo cual nos permite no s√≥lo tener una descripci√≥n del c√≥digo con texto plano sino de manera gr√°fica poder ver los resulrado de los d√°tos analizados. Adicionalmente se puede hacer uso de tiempo de animaciones para complementar las narrativas.\nLos notebooks en cierta forma han ido remplazando el uso de las terminales interactivas, pues enriquecen las descripci√≥n del c√≥digo y facilitan la visualizaci√≥n. Al tener los mismos beneficios que las terminales interactivas y poder hacer pruebas con peque√±os fragmentos de c√≥digo la presentaci√≥n del c√≥digo desarrollado resulta de f√°cil lectura. Adicionalmente se tienen ciertas herramientas que ayudan al desarrollo las cuales han sido pensadas para los usos m√°s comunes. Conocer todas las funcionalidades de los notbooks de jupter queda fuera del alcance de este curso pero veremos ciertas cosas b√°sicas para poder trabajar con ellos.\nUsaremos JupyterLab el cual integra una plataforma web para generar notebooks, esta interfaz se hace desplegando un servicio web de forma local y puede ser accedida desde cualquier navegador web. Aunque en este curso se utiliza Python tambi√©n los notebooks de Jupyter-lab puede hacer uso de distintos lenguajes de programaci√≥n como son R, Julia.\n\n\nPara su instalaci√≥n desde un ambiente virtual de conda se ejecuta\n(desarrollo) conda install -c conda-forge -y jupyterlab\nO con pip\n(desarrollo) pip install jupyterlab\n\n\n\nPara iniciar una instancia de JupyterLab desde terminal dentro del ambiente virtual que se genero se hace usando el siguiente comando\n(desarrollo) jupyter-lab\nEn windows tambien se puede hacer uso de la interfaz gr√°fica de conda para lanzar el JupyterLab.\n\n\n\nFigure¬†1: Inicio de JupyterLab\n\n\nUna vez ejecutado el comando se desplegara un servicio web el cual se puede acceder desde un navegador y nos mostrara una pagina web muy similar a la que se muestra en Figure¬†1.\nPara empezar un nuevo notebook se elige la version de python que se desea que se ejecute y esta generar√° un nuevo notebook con nombre ‚ÄòUntitled.ipynb‚Äô como en Figure¬†2\n\n\n\nFigure¬†2: Nuevo Notebook\n\n\nEn los notebooks se tienen tres tipos de celda (‚ÄòCode‚Äô, ‚ÄòMarkdown‚Äô y ‚ÄòRaw‚Äô) las cuales se usan con distintos propositos.\n\n‚ÄòCode‚Äô se utiliza para la ejecuci√≥n de c√≥digo\n‚ÄòMarkdown‚Äô nos permite hacer uso de el lenguaje Markdown para el enriquecimiente del texto plano.\n‚ÄòRaw‚Äô simplemente va a mostrar el contenido dentro de la celda.\n\nComo ejemplo este curso hace uso de los Notebooks y Markdown, como se ve es de especial √∫tilidad para la creaci√≥n de texto relacionado con la creaci√≥n de c√≥digo y para la generaci√≥n de manuales t√©cnicos.\n\n\n\nMarkdown es un simple conjunto de instrucciones en texto plano que nos permiten enriquecer el texto para crear documentos m√°s completos. Las siguientes son una muestra de como se utiliza Markdown.\n\n\nLa letra cursiva es un recurso que se utiliza en la creaci√≥n de texto para resaltar alguna palabra en particular para distinguirla del texto usual. Es com√∫n utilizarla para palabras en otro idioma como ballet o software. En el caso de las ciencias es com√∫n su uso cuando se hace uso del lat√≠n como curriculum vitae.\nPara escribir con negritas en Markdown se utiliza el caracter *, todo lo que se entre los aster√≠scos queda como cursiva *cursiva*.\n\n\n\nLa letras en negritas nos sirve para resaltas una palabra o palabras del texto normal. Para que el texto este en negritas en Markdown tenemos que colocarlo entre dos asteriscos ** **. De esta forma podemos hacer enfasis **enfasis** en algo particular.\n\n\n\nEn ciertos casos es necesario escribir c√≥digo dentro del texto sin que este sea ejecutado por tal motivo se utiliza la tilde invertida (`) y nos permite escribir cosas sin que estas sean ejecutadas en los distintos lenguajes soportados por Quarto 1+1 `1+1`.\n\n\n\nPara hacer listas en Markdown es muy f√°cil pues esto se puede hacer usando un s√≥lo * para definirlas, y un espacio para determina la lista.\n\nCosa 1\nCosa 2\nCossa 3\n\nCosa 3.1\nCosa 3.\n\n\n* Cosa 1\n* Cosa 2\n* Cossa 3\n    * Cosa 3.1\n    * Cosa 3.2\n\n\n\nMarkdown nos permite tener mantener un orden dentro del documento haciendo uso de #, este funciona para indicar un encabezado e inicio de la secci√≥n. Markdown nos permite hacer subsecciones a partir del uso consecutivo de #.\n# Secci√≥n 1\n\n# Secci√≥n 2\n\n# Secci√≥n 3\n\n## Secci√≥n 3.1\n\n### Secci√≥n 3.1.1\n### Secci√≥n 3.1.2\n\n## Secci√≥n 3.2 \n## Secci√≥n 3.3\n\n# Seccion 4\n\n\n\n\nMarkdown nos permite hacer tablas referencia insertar imagenes, etc. Se puede hacer un curso para conocer los distintos usos de forma m√°s extensiva,pero queda fuera del alcance de este curso.\n\n\n\n\nGit es un systema de control de versiones, aunque existen distintos sistemas de control de versiones git es el m√°s utilizado. Los sistemas de control de versiones son una herramienta fundamental en el desarrollo de software pues nos permiten tener un control sobre las versiones del c√≥digo desarrollado a trav√©s de los cambios en el ƒáodigo. A trav√©s del seguimiento de dichos cambios es posible tener un trabajo en equipo sobre el mismo archivo de forma aut√≥noma permitiendo un desarrollo m√°s r√°pido.\nUna de las herramientas m√°s usadas en los sistemas de control de versiones es la idea b√°sica para lo que fueron creados que es poder regresar a una versi√≥n anterior en el desarrollo de software, lo cual resulta fundamental si hay un error en el desarrollo (bug).\ny se recomienda tener una mejor comprensi√≥n de los mismos. Por desgracia esto queda fuera del campo de este curso y s√≥lo daremos una explicaci√≥n simplificada de esto.\nGit es un sistema de control de versiones . Los sistemas de control de versiones. . De igual forma nos facilita encontrar y corregir los posibles bugs dentro del c√≥digo.\nExisten distintos servicios para almacenar c√≥digo de manera remota dentro de los cuales podemos destacar github y gitlab. En este curso se utiliza github por facilidad pues se usa su servicio de github-pages para tener en linea la documentaci√≥n del paquete que se desarrolla.\nPara la instalaci√≥n de git dentro de un ambiente virtual de anaconda se puede hacer de la siguiente forma\n(desarrollo) conda install -c conda-forge git\nLo m√°s seguro es que git ya se encuentre instalado en su sistemas, al menos es el caso para Mac y Linux. Para saber si se tiene instalado git se puede abrir una terminal y ejecutar:\ngit version\nEste comando mostrara la versi√≥n instalada dentro del sistema.\nEn caso de que no se tenga instalado se puede seguir los pasos que se encuentran en Github o se puede descargar desde https://git-scm.com/download/win. Usando cualquiera de los dos metodos su instalaci√≥n ser√° de forma global, en caso de desear instalarlo dentro de una ambiente virtual se puede hacer con conda o usando el canal oficial de anaconda:\nconda install -c anaconda git\no el canal de la comunidad conda-forge:\nconda install -c conda-forge git\n\n\n\n\n\n\nLa instalaci√≥n de nbdev es igual de f√°cil que los anteriores paquetes, pero en este caso se utiliza el canal de la empresa que desarrolla nbdev. Se instala a trav√©s de pip usando:\npip install nbdev\no instalar con conda:\nconda install -c fastai nbdev\n\n\n\nLa instalaci√≥n en Windows es distinta pues es necesario hacerla desde PIP y usar una version especifica, al momento de escribir este curso la instalaci√≥n disponible a trav√©s de PIP no funciona de forma totalmente correcta, por tal motivo vamos a especificar la version para hacer uso de esta.\npip install nbdev=2.3.12\n\n\n\nYa con la instalaci√≥n de nbdev un comando del mismo nos permite instalar Quarto en ael caso de Mac o Linux esto se puede hacer una vez instalado nbdev usando el comando\nnbdev_install_quarto\n\n\nSi se desea se puede instalar siguiendo los siguientes pasos para usar con el IDE de preferencia. Esta instalaci√≥n tendra disponible quarto en todo el sistema y no s√≥lo para el ambiente de desarrollo. Aunque es posible hacer la instalaci√≥n dentro de un ambiente de desarrollo, esto queda fuera de de una explicaci√≥n b√°sica.\n\n\n\nEs recomendable instalar ciertos plug-ins para hacernos la vida m√°s f√°cil estos se hace ejecutando,\nnbdev_install_hooks"
  },
  {
    "objectID": "contenido/Contenido/Tema2_extendido/1_pasos.html",
    "href": "contenido/Contenido/Tema2_extendido/1_pasos.html",
    "title": "Curso Nbdev- Primeros pasos",
    "section": "",
    "text": "A continuaci√≥n vamos a poner los pasos que vamos a seguir para crear un ambiente de desarrollo y automatizar todos los procesos.\n\nGenerar un repositorio.\nHabilitar Github Pages.\nHacer la primera edici√≥n.\nVer la documnetaci√≥n local\nConstruir m√≥dulos.\nA√±adir cambios Github\n\n\n\n\nLos repositorios nos permiten mantener un orden en el c√≥digo y un control de cambios, por la simpleza usaremos Github donde alojaremos el repositorio de nuestro desarrollo. Para poder crear un repositorio dentro de github sera necesario crear una cuenta dentro del sitio.\n\n\n\nFigure¬†1: Nuevo repositorio\n\n\nUna vez creado nuestro repositorio se utiliza el siguiente comando para clonar el repositorio de forma local y poder modificarlo tanto de forma local como actualizar los cambies en github.\ngit clone git@github.com:%nombreusuario/nbdev_prueba.git\nPodemos observar que no hay nada dentro del repositorio, incluso cuando se ejecuta el c√≥digo anterior nos muestra una advertencia que estamos clonando un repositorio vacio.\nwarning: You appear to have cloned an empty repository.\nNbdev contiene un comando para a√±adir toda la estructura necesaria para poder generar nuestro paquete junto con su documentaci√≥n.\nnbdev_new\nEste comando debera ejecutarse dentro del directorio del repositorio. El comando generar√° tres subdirectorios:\n\nUn subdirectorio con el nombre del repositorio (nbdev_prueba)\nnbs\n_proc\n\nY unos archivos\n\nLicense\nMANIFEST.in\nREADME.md\nsettings.ini\nsetup.py\n\nDe los anteriores, el que nos interesa es el settings.ini en el cual se controla la mayor√≠a de las cosas dentro de nuestro paquete.\nVamos a modificar nuestro repositorio en github para ver que todo se sincronize y funcione.\n$ git add .\n$ git commit -m 'Primer commit'\n$ git push\nSi vamos a nuestro repositorio dentro de Github podemos observar que ya tenemos los archivos y los subdirectorios en Github igual que lo tenemos dentro de nuestros archivos locales Ver ?@fig-nbd-modificado.\n\n\n\nNuevo repositorio\n\n\n\n\n\nUna de cosa que nos promete nbdev es la generaci√≥n de documentaci√≥n, pero es necesario tener un lugar donde se pueda consultar. Un lugar donde podemos tener alojada la documentaci√≥n es en Github Pages la cual nos permite generar un sitio web con la documentaci√≥n desde el repositorio.\n\n\n\n\n\n\nNote\n\n\n\nAunque nbdev tiene por defecto el uso de Github Pages esto puede ser modificado y tener alojada la documentaci√≥n en otra parte.\n\n\nPara habilitar en el repositorio hay que ir a la parte de ‚ÄúSettings‚Äù del repositorio y en el menu (Izquierda) en ‚ÄúPages‚Äù. En esta secci√≥n se cambia de ‚ÄúBranch‚Äù a ‚Äúgh-pages‚Äù y se da click en ‚ÄúSave‚Äù.\n\n\n\nNuevo repositorio\n\n\nLa p√°gina se encuentra alojada en una direcci√≥n similar a https://%nombreusuario.github.io/nbdev_prueba/. Pero primero esta debe ser generada por Github.\nUna de las caracter√≠sticas de Github es que podemos generar ciertas acciones y flujos de trabajo de forma automatizada dentro del repositorio. Estas acciones nos permiten verificar que tanto el c√≥digo del paquete funcione de manera adecuada, como el despliegue de nuestra documentaci√≥n se haga de forma correcta. Integrando esto evitamos el desgaste de hacerlo de forma manual.\nCuando nuestra pagina de documentaci√≥n se encuentre disponible en la pesta√±a de ‚ÄúActions‚Äù del repositorio podremos ver (‚úÖ) en ‚Äúpages build and deployment‚Äù. En caso de que se vea (‚ùå) significa que algo a salido mal.\n\n\n\nDeploy documentacion\n\n\nPara poder ver la documentaci√≥n que se creo, nos podemos dirigir a la la cual estar√° alojada en algo similar a https://%nombreusuario.github.io/nbdev_prueba/\n\n\n\nDocumentacion\n\n\n\n\n\n\n\n\nIntegraci√≥n continua\nAl tener todo integrado facilitamos el trabajo del desarrollador, aprovechando el tiempo y librando de tareas que pueden resultar engorrosas y que lleva tiempo realizar.\n\n\n\n\n\n\nYa que hemos generado un repositorio y hemos modificado las configuraciones para tener la documentaci√≥n alojada de forma automatica vamos a hacer la primera edici√≥n a nuestro paquete.\n\n\nAntes de esto vamos a ejecutar el siguiente comando\n$ nbdev_install_hooks\nEste comando nos permite instalar ciertas extensiones en jupyter Notebook y JupyterLab, las cuales nos permitiran limpiar los notebooks de metadatos que no son necesarios en los repositorios. Y arreglar ciertos elementos de los notebooks los cuales pueden llegar a causar conflictos cuando se hace uso de las acciones de git.\nEsto nos ayuda, pues es com√∫n que ciertos datos se modifiquen sin haber editato el notebook, esto sucede por el simple hecho de hacer su ejecuci√≥n o abrir el notebook.\n\nnbdev_merge Nos ayuda a poner los notebooks de forma que al hacer el uso de acciones de pull merge, rebase o stash dentro de git, no modifiquen los notebooks y estos se puedan ejecutar entre los colaboradores del repositorio.\nnbdev_clean Los notebooks de Jupyter incluyen muchos metadatos que no se llevan bien con sistemas de control como git. Por tal motivo nbdev installa un ‚Äúhook‚Äù el cual elimina estos metadatos o los remplaza por versiones gen√©ricas que no afectan la ejecuci√≥n o visualizaciones dentro del notebook.\nnbdev_trust Un efecto secundario que se tiene al hacer uso de los notebooks de Jupiter es que estos no funcionan dentro de repositorios compartidos. La raz√≥n es que estos pueden ejecutar c√≥digo HTML o c√≥digo de JavaScript el cual puede llegar a contener codigo malicioso. Por tal motivo el comportamiento por defecto de los notebooks de Jupyter es preguntar si se puede confiar en el notebook cada vez que se abre esto puede ser una problem√°tica en el flujo de trabajo por tal motivo se puede correr nbdev_trust para evitar que cada vez que se abre un notebook pregunte si es de confianza.\n\n\n\n\n\n\n\nDanger\n\n\n\nAdvertencia\nNo se debe de usar los hooks de nbdev dentro de un repositorio que no se confie.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nLos hook de nbdev funcionan para cualquier repositorio, sin importar si se usa nbdev o no para generar un paquete o biblioteca.\n\n\n\n\n\n\nNbdev es muy modificable, esto se encuentra dentro del archivo settings.ini. Para crear el archivo se puede ejecutar nbdev_create_config.\n\n\n\nAbrimos el archivo nbs/00_core.ipynb, el cual se gener√≥ cuando ejecutamos nbdev_new. Dentro de √©ste se pueden observar las directrizes m√°s importantes para generar un documento que nos servira para poder hacer tanto nuestro paquete, la documentaci√≥n y su empaquetado.\nExpliquemos el comportamiento de las celdas que se encuentran dentro de este notebook.\nLa primera celda contiene\n# core\n\n> Fill in a module description here\naqu√≠ definimos que el m√≥dulo a crear se llamara core y la descripci√≥n del mismo. La celda contiene un encabezado H1 de Markdown #y una cita de Markdown donde se describe el m√≥dulo.\nLa segunda celda\n#| default_exp core\nes una directriz en la cual se decide el m√≥dulo al cual el notebook exportar√° lo que se desee. Como se encuentra se exporta al m√≥dulo core.\nEn la siguiente celda\n#| hide\nfrom nbdev.showdoc import *\nla directriz #| hide nos dice que esta celda no parecer√° y tampoco la salida de la misma. Esto nos sirve para poder hacer ciertas pruebas pero que no se desean que sean exportadas ni que sean parte de la documentaci√≥n.\nEn la celda siguiente\n#| export\ndef foo(): pass\nla directriz #| export exportar√° el contenido de la celda al m√≥dulo.\nLa √∫ltima celda\n#| hide\nimport nbdev; nbdev.nbdev_export()\nusa la directriz #| hide para ocultar el c√≥digo y la salida de la celda, lo que se ejecuta dentro de la celda es lo que permite exportar lo que se indic√≥ dentro del notebook al m√≥dulo.\nVamos a modificar este notebook para hacer un m√≥dulo con funciones sencillas.\nAgregamos la siguiente celdas antes de la √∫ltima celda en el notebook sin editar.\n#| export\ndef saludo():\n    \"\"\"Imprime Hola\"\"\"\n    print('Hola!')\n    return\nsaludo()\n#| export\ndef saludo_a(to):\n    \"\"\"Imprime hola a un nombre\"\"\"\n    print('Hola!', to)\n    \n    print('Espero que te encuentres bien')\n    return\nsaludo_a('Raul')\nshow_doc(saludo_a)\nLas celdas sin la directriz #| export nos pueden servir para probar las funcionalidades dentro del m√≥dulo o bien para ser parte de la documentaci√≥n como ejemplos. En la celda se utiliza la funci√≥n show_doc nos sirve para mostrar el uso de la cocumentaci√≥n iterna de la funci√≥n saludo_a esta nos sirve para generar una documentaci√≥n precisa.\nAhora podemos executar todo el notebook usando el boton ‚è© dentro de jupyterlab. Si todo funciona correctamente podemos generar la documentaci√≥n, hacer pruebas y exportar a un m√≥dulo.\n\n\n\n\nPara poder ver la documentaci√≥n de forma local se executa el siguiente comando desde el folder del repositorio\n$ nbdev_preview\nEl comando construye la documentaci√≥n usando los noteboooks que se encuentran dentro del directorio ‚Äònbs/‚Äô. Y genera un servicio de pagina web de forma local a la cual podemos acceder desde nuestro navegador.\nLa configuraci√≥n se puede controlar desde el archivo settings.ini y por defecto toma a ‚Äònbs/index.ipynb‚Äô como la pagina principal. A la izquierda nos muestra una columna donde podemos ir a la documentaci√≥n del modulo ‚Äúcore‚Äù. Podremos observar que se encuentran las modificaci√≥nes que se hicieron al m√≥dulo.\nSi se mantiene en servicio la p√°gina es posible ver los cambios que se hacen con cierto retraso.\n\n\n\nDocumentacion Modificada\n\n\n\n\n\nPara probar que el todos los elementos del m√≥dulo funciona de forma correcta y si alguna modificaci√≥n hecha no afecta en el desempe√±o de los componentes de los m√≥dulos en nuestro proyecto se utiliza el siguiente comando\n$ nbdev_test\nSi todo esta correcto en la consola se desplegara\nSuccess.\nEn caso contrario se muestran los errores y se especifica los notebook en donde se encuentran.\nnbdev_test puede usarse para probar de manera individual los notebooks\n$ nbdev_test --path notebook.ipynb\nO para todo un directorio\n$ nbdev_test --path tests/\n\n\n\nPara generar la documentaci√≥n, desde la linea de comandos en el directorio de nuestro repositorio se llama el comando:\n$ nbdev_export\nEste comando genera nuestro m√≥dulo ‚Äòcore‚Äô el cual se encontrar√° dentro del directorio ‚Äònbdev_prueba‚Äô. Si se desea se pueda abrir el archivo core.py el cual contiene una leyenda\n>  # AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.\ninformando que el archivo fue autogenerado y que cualquier modificaci√≥n debe de hacerse dentro del notebook nbs/00_core.ipynb.\nEn core.py podemos ver que se encuentran las funciones definidas dentro del notebook en las celdas con la directriz #| export.\nEl m√≥dulo generado forma parte de la nuestro proyecto.\nPor defecto al ejecutar nbdev_export se puede hacer sobre todos los notebooks del projecto. Tambi√©n se puede hacer sobre un notebook en espec√≠fico.\nnbdev_export --path notebook.ipynb\no un directorio\nnbdev_export --path dir/\nEsto solo sucedera si al principio del notebook se a√±ade la directriz #| default_exp core al principio del notebook.\n\n\n\nPara mantener el c√≥digo usando Github limpiamos los notebooks con\n$ nbdev_clean\nEl comportamiento usual es limpiar todos los notebook que se encuentran en el directorio declarado en el archivo settings.ini en la parte de nbdev nbs_path = nbs pero tambi√©n puede se puede limpiar un solo notebook\n$ nbdev_clean --fname notebook.ipynb\nTambien podemos ejecutar\n$ nbdev_readme \nel cual actualiza el Readme.md del repositorio.\n\n\n\nYa podemos hacer los ‚Äòcommits‚Äô y ‚Äòpush‚Äô a los cambios en el repositorio para que estos se actualizen en Github. Nbdev nos da un comando para hacer todo para disminuir el tiempo para los cambios. Esto se puede hacer usando\n$ nbdev_prepare \nel cual exporta, prueba, limpia los notebooks y modifica el README del repositorio\n$ git add .\n$ git commit -m 'El primer commit con modificaciones' # Cambie el texto por el que se desee\n$ git push\n\n\nLa biblioteca se puede a√±adir a PIP o Anaconda en cualquiera de los casos es necesario tener una cuenta para hacer estas acciones.\nEn este caso se dan los pasos para hacer las instalaci√≥n desde github usando pip install.\npip install \"Nombre\" @ git+\"URL del repositorio\"\nEn nuestro caso\npip install nbdev-prueba@git+https://github.com/\"Nombre_usuario_github\"/nbdev_prueba\nDe esta forma ya tenemos la biblioteca instalada dentro de nuestro ambiente de python. Para ver esto podemos abrir una terminal de python e importar el m√≥dulo core de nuestra biblioteca.\nfrom nbdev_prueba import core\ncore.saludo_a('Juan')\nY obtenemos como resultado\nHola! Juan\nEspero que te encuentres bien"
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html",
    "title": "Curso Nbdev ‚Äì M√≥dulo con Clusters",
    "section": "",
    "text": "Un uso com√∫n en el mundo de los datos es el uso de algoritmos de agrupamiento o clusterizaci√≥n. A continuaci√≥n vamos a tomar distintos algoritmos de clusterizaci√≥n y vamos a ponerlos todos dentro de un m√≥dulo. Este simple ejemplo aunque sencillo nos mostrar√° de forma m√°s extensa el uso de nbdev.\nPrimero generamos nuestro repositorio como lo hicimos en el ejemplo anterior.\nUna vez con nuestro repositorio podemos iniciar nuestro repositorio de forma local y vamos a modificarlo para hacer el m√≥dulo de ejemplo.\n\n\nEn la secci√≥n anterior vimos como construir un ejemplo b√°sico, en este vamos a generar un m√≥dulo que tenga una biblioteca simple donde contenga ejemplos b√°sicos de clusterizar.\nEntendamos la estructura que utiliza nbdev para generar nuestra nueva biblioteca, en el directorio nbs se encuentran los notebooks que vamos a modificar en nuestro ejemplo. al momento de creacion del repositorio una vez ejecutado el comando nbdev_new nos genera toda la estructura dentro de nuestro repositorio.\nSi no se hizo de la misma forma que como se describio anteriormente, esto se puede hacer de forma manual, se ejecuta el mismo comando y se rellenan los campos solicitados\n> nbdev_new\n\n\n\nFigure¬†1: Salida nbdev_new\n\n\nEn el archivo settings.ini podemos ver las configuraciones, como ejemplo podemos ver que el archivo recien creado en el repositorio muestra los valores que se insertaron.\n\n\n\nFigure¬†2: contenido de settings.ini\n\n\nEn este archivo se puede modificar cosas como la licencia, la url de la documentaci√≥n, donde se aloja la documentaci√≥n, el autor, el nombre de la biblioteca, el path de donde se localizan los notebooks, etc.\nComo ya hemos visto para modificar algo en nuestra biblioteca es necesario hacerlo en los notebooks, con este proposito, nbdev generar√° los archivos correspondientes tanto de la documentaci√≥n, como los archivos con c√≥digo que corresponden a nuestra biblioteca.\nTambi√©n nbdev generar√° el archivo README.md el cual sirve como portada en nuestro repositorio. Para hace modificaciones a este, se deben hacer desde el archivo nbs/index.ipynb el cual nos permitir√° una vez terminada nuestra biblioteca dar instrucciones simples para su instalaci√≥n as√≠ como la posibilidad de a√±adir links a la documentaci√≥n de nuestra biblioteca. Se puede generar √∫nicamente el archivo README.md ejecutando el comando nbdev_readme, una vez ejecutado se puede abrir el archivo y ver las modificaciones realizadas.\nnbdev_readme\nSi se desea ver desde github sera necesario actualizar los cambios en el repositorio, para esto haremos un ejemplo desde la terminal s√≥lo se muestra como ejemplo pues un curso completo de git queda fuera de los temas de este curso.\ngit add README.md\ngit commit -c \"Se modifica el README\"\ngit push\n\ngit add README.md a√±ade el archivo que se modifico y que se desea que actualizar, o bien a√±adir el archivo si no se tiene dentro de nuesto conjunto de archivos vigilados.\ngit commit -c \"Se modifica el README\" se ‚Äúcomitea‚Äù es decir se a√±ade a un registro de cambios de forma local los cambios hechos. -c es para a√±adir el comentario \"Se modifica el README\" a los cambios hechos, esto nos sirve como gu√≠a para ver que cambios se han hecho y cual fue la razon de nuestros cambios. Esto es muy √∫til cuando se busca errores en el desarrollo y poder regresar al estado anterior.\ngit push Sube los cambios hechos a el servidor de git, en nuestro caso lo va a subir a github pues el es servicio que determinamos usar.\n\nPodemos ver las modificaciones en nuestro repositorio.\n\n\n\nOtros comandos importantes de git\n\ngit clone sirve poara clonar repositorios\ngit pull sirve para traer los cambios desde el servidor de git. El servidor depende de donde se tiene el servicio (github, gitlab o similares).\ngit config configura distintos valores de el repositorio.\ngit config ‚Äìglobal user.name ‚ÄúTu nombre‚Äù Cambia el valor de nombre de usuario de forma global.\ngit config ‚Äìglobal user.email ‚Äútumail@example.com‚Äù Cambia el valor global del mail.\ngit init Crea un nuevo repositorio.\ngit commit -a ‚ÄúComitea‚Äù todos los archivos a√±adidos anteriormente al repositorio.\ngit status Enlista los archivos que se han cambiado dentro y aquellos que todavia se necesitan a√±adir o ‚Äúcomitear‚Äù.\ngit checkout -b <nombre_rama> crea una nueva rama en el repositorio.\ngit checkout <nombre_rama>cambia a la rama .\ngit branch Enlista todas las ramas en el repositorio y en que rama te encuentras actualmente.\ngit branch -d <nombre_rama> Borra la rama ."
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html#clase-clusters",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html#clase-clusters",
    "title": "Curso Nbdev ‚Äì M√≥dulo con Clusters",
    "section": "Clase clusters",
    "text": "Clase clusters\nVamos a√±adir una nueva clase a nuestro m√≥dulo, la cual llamaremos Clusters, esta clase nos sirve para generar clusters usando distintos algoritmos.\nclass data_points:\n    \"\"\"Una clase que contiene a los datos\"\"\"\n    def __init__(self, n, min_x = 0, min_y = 0, max_x= 1, max_y=1, seed= None):\n        if seed != None:\n            random.seed(seed)\n\n        Xpoint = np.random.uniform(low= min_x, high= max_x, size=n)\n        Ypoint = np.random.uniform(low= min_y, high= max_y, size=n)\n        \n        #self.Points = np.random.uniform(low= min_x, high= max_x, size=(n, 2))\n        self.Points =  [shapely.Point(x[0],x[1]) for x in zip(Xpoint, Ypoint)]\n    \n    @classmethod\n    def from_list(cls, list_points):\n        \"\"\"Se genera los datos usando una lista de puntos\"\"\"\n        toto = cls(0)\n        toto.Points = list_points\n        return toto\n    \n    def get_points(self):\n        \"\"\"Una funcion que para obtener los puntos\"\"\"\n        return self.Points\n\n    def get_Multypoint(self):\n        \"\"\"Regresa un objeto MultiPoint con los puntos\"\"\"\n        return shapely.geometry.MultiPoint(self.Points)\n    \n    def get_X(self):\n        \"\"\"Regresa las coordenadas X\"\"\"\n        return [x.x for x in self.Points]\n\n    def get_Y(self):\n        \"\"\"Regresa las coordenadas X\"\"\"\n        return [x.y for x in self.Points]\n    \n    def centroid(self):\n        \"\"\"Regresa el centroide de los puntos \"\"\"\n        return shapely.centroid(self.get_Multypoint())\n    \n    def as_array(self):\n        \"\"\"Regresa los puntos como un array\"\"\"\n        list_arrays = np.array([ (geom.xy[0][0], geom.xy[1][0]) for geom in self.Points])\n        return list_arrays\n\n    def add_points(self, data_points):\n        \"\"\"Agrega puntos de otra \"\"\"\n        self.Points = self.Points + data_points.Points\n        return         \nPara exportar la clase al m√≥dulo es necesario a√±adir la directriz #| export al inicio de la celda. Adicionalmente a√±adimos pruebas simples usando los datos que ya se generaron.\ncluster_all  = Clusters(datos_simples)\ncluster_all.DBSCAN()\ncluster_all.KMeans()\ncluster_all.HDBSCAN()\ncluster_all.OPTICS()\nComo estas celdas nos sirven de pruebas vamos a a√±adir la directriz #| hide para evitar que estas sean parte de la documentaci√≥n. Ahora podemos a√±adir ejemplos del uso de la clase cluster e incluso a√±adir como se usan los metodos."
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html#documentaci√≥n",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html#documentaci√≥n",
    "title": "Curso Nbdev ‚Äì M√≥dulo con Clusters",
    "section": "Documentaci√≥n",
    "text": "Documentaci√≥n\nPara generar la documentaci√≥n se hace usando el comando\nnbdev_docs\nEn este caso en nuestra terminal podemos observar lo que se muestra en la imagen Figure¬†4, como se observa en el directorio _docs se encuentra un archivo html que puede abrirse usando un navegador y se puede ver la documentaci√≥n y se puede ver que solo muestra el ‚Äòdocstring‚Äô generado por las clase como en la figura Figure¬†3 y el respectivo para la clase Clusters.\n\n\n\nFigure¬†4: Generaci√≥n documentaci√≥n\n\n\nPara mostrar un poco m√°s lo que hace nuestra clase simple a√±adimos las siguientes celdas\nshow_doc(Clusters.KMeans)\nshow_doc(Clusters.DBSCAN)\nshow_doc(Clusters.HDBSCAN)\nshow_doc(Clusters.OPTICS)\nEstas mostraran lo que se haya puesto dentro de los ‚Äòdocstrings‚Äô de los m√©todos en la clase Cluster.\nTambi√©n podemos generar la documentaci√≥n y hacer una previsualizaci√≥n haciendo uso del comando\nnbdev_preview\nlo cual nos mostrara\n\n\n\nFigure¬†5: Muestra la documentaci√≥n\n\n\nllevandonos a la documentaci√≥n de forma local.\n\n\n\n\n\n\nActividad\n\n\n\n\n\nMuestre los m√©todos para la clase data_points en la documentaci√≥n"
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html#mas-documentaci√≥n",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html#mas-documentaci√≥n",
    "title": "Curso Nbdev ‚Äì M√≥dulo con Clusters",
    "section": "Mas documentaci√≥n",
    "text": "Mas documentaci√≥n\nPodemos hacer uso de las facilidades de los jupyter notebooks para generar ejemplos y tutoriales, para esto vamos hacer dentro del mismo notebook.\nCreamos un conjunto de datos usando los distintos metodos en las clases que ya hicimos.\ndatos_simples_3 = data_points(500, min_x = 0.6, min_y= 0.6, max_x= 1.0, max_y= 1.0 )\ndatos_simples_2 = data_points(500, min_x = 0.0, min_y= 0.6, max_x= 0.4, max_y= 1.0 )\ndatos_simples_1 = data_points(500, min_x = 0.6, min_y= 0.0, max_x= 1.0, max_y= 0.4 )\ndatos_simples_0 = data_points(500, min_x = 0.0, min_y= 0.0, max_x= 0.4, max_y= 0.4 )\nUnimos todos los puntos con el metodo add_points de la clase data_points.\ndatos_simples_0.add_points(datos_simples_1)\ndatos_simples_0.add_points(datos_simples_2)\ndatos_simples_0.add_points(datos_simples_3)\nVeamos los puntos dentro de nuestra estructura.\ndatos_simples_0.get_Multypoint()\nAhora inicialicemos nuestro objeto Clusters\ncluster_all  = Clusters(datos_simples_0)\nY ahora podemos hacer uso de los algoritmos usando los metodos de las distintas las clusterizaciones.\ncluster_all.OPTICS()\ncluster_all.HDBSCAN()\ncluster_all.DBSCAN(eps=0.1, min_samples=10)\ncluster_all.KMeans()\nY visualizemos las clusterizaciones\nfig, ax = plt.subplots(1,1, figsize=(6,6))\nplt.scatter(\n        cluster_all.data_structure.get_X(),\n        cluster_all.data_structure.get_Y(),\n        c = cluster_all.data_structure.classes_Kmeans\n    )\nfig, ax = plt.subplots(1,1, figsize=(6,6))\nplt.scatter(\n        cluster_all.data_structure.get_X(),\n        cluster_all.data_structure.get_Y(),\n        c = cluster_all.data_structure.classes_DBSCAN\n    )\nfig, ax = plt.subplots(1,1, figsize=(6,6))\nplt.scatter(\n        cluster_all.data_structure.get_X(),\n        cluster_all.data_structure.get_Y(),\n        c = cluster_all.data_structure.classes_HDBSCAN\n    )\nfig, ax = plt.subplots(1,1, figsize=(6,6))\nplt.scatter(\n        cluster_all.data_structure.get_X(),\n        cluster_all.data_structure.get_Y(),\n        c = cluster_all.data_structure.classes_OPTICS\n    )\nSi se ejecuta nbdev_preview o nbdev_docs en la documentaci√≥n mostrara el ejemplo dentro de la misma.\nAhora para preparar verificar que todo esta bien ejecutamos\nnbdev_prepare\nLo cual mostrara  si no hay ningun problema. En el fondo lo que hace nbdev_prepare preprocesar los archivos dentro de nbs y generar los"
  },
  {
    "objectID": "contenido/Contenido/Tema3/Clusters_ejemplo.html#entendiendo-github-actions.",
    "href": "contenido/Contenido/Tema3/Clusters_ejemplo.html#entendiendo-github-actions.",
    "title": "Curso Nbdev ‚Äì M√≥dulo con Clusters",
    "section": "Entendiendo github-actions.",
    "text": "Entendiendo github-actions.\nLas acciones de Github acitions nos permiten realizar acciones automatizadas dentro de nuestro directorio de Github, en nuestro caso dichas acciones se encuentran dentro de los archivos que se encuentran en el directorio .github dentro del directorio workflows los cuales son deploy.yaml y test.yaml. Estos dos archivos controlan los dos flujos de trabajo que se realizan dentro de github. Vamos a modificarlos y explicad un poco que hacen cada uno.\nEl archivo deploy es el que utilizamos para generar la documentaci√≥n, vamos a sustituir el contenido del archivo con el que se encuentra en la celda siguiente:\n\nArchivo deploy.yaml\nname: Deploy to GitHub Pages\non:  [workflow_dispatch, pull_request, push] \npermissions:\n  contents: write\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps: \n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n      - name: Install Dependencies and create documentation \n        shell: bash\n        run: |\n          python -m pip install --upgrade pip\n          pip install -Uq git+https://github.com/fastai/ghapi.git # you need this for enabling pages\n          pip install -Uq git+https://github.com/fastai/fastcore.git\n          pip install -Uq git+https://github.com/fastai/execnb.git\n          pip install -U git+https://github.com/fastai/nbdev.git\n          wget -q $(curl https://latest.fast.ai/pre/quarto-dev/quarto-cli/linux-amd64.deb)\n          sudo dpkg -i quarto*.deb\n          pip install -Uq matplotlib\n          pip install -Uq setuptools\n          pip install -Uq scikit-learn\n          pip install -Uq shapely\n          nbdev_docs\n#          pip install -e \".[dev]\"\n         \n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v4\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          force_orphan: true\n          publish_dir: ./_docs\n          # The following lines assign commit authorship to the official GH-Actions bot for deploys to `gh-pages` branch.\n          # You can swap them out with your own user credentials.\n          user_name: github-actions[bot]\n          user_email: 41898282+github-actions[bot]@users.noreply.github.com\nExpliquemos a grandes razgos lo que esta haciendo este archivo. Las primeras lineas le dan nomble a la accion y cuando se realiza esta. En este caso llamamos a la acion ‚ÄòDeploy to GitHub Pages‚Äô y la accion sera realizada cuando se solicite de forma manual (‚Äòworkflow_dispatch‚Äô) cuando se haga una petici√≥n pull (‚Äòpull_request‚Äô) o bien quando se realize un pull.\nname: Deploy to GitHub Pages\non:  [workflow_dispatch, pull_request, push] \nEl trabajo que va a realizar se denomina ‚Äòdeploy‚Äô el cual utilizara una maquina con la version m√°s reciente de ubuntu para realizarlo (‚Äòubuntu-latest‚Äô).\nEn las siguientes lineas estamos dando permiso a la maquina virtual de poder escribir dentro de nuestro repositorio.\npermissions:\n  contents: write\nDespues el trabajo consiste en los siguientes pasos:\n- uses: actions/checkout@v3\n- uses: actions/setup-python@v4\nUtiliza las acciones actions/checkout@v3 y actions/setup-python@v4 que son acciones que tenemos estandarizadas dentro de github actions. Las cuales hace un check out del repositorio dentro de la maquina virtual para realizar el trabajo. actions/setup-python@v4 instala python dentro de la maquina virtual.\nEl siguiente paso lo llamamo ‚ÄòInstall Dependencies and create documentation‚Äô aqui podemos ver que hacemos un conjunto de acciones que hicimos con anterioridad cuando instalamos las cosas necesarias para hacer uso de nbdev, git, quarto, etc.\n- name: Install Dependencies and create documentation \n    shell: bash\n    run: |\n    python -m pip install --upgrade pip\n    pip install -Uq git+https://github.com/fastai/ghapi.git # you need this for enabling pages\n    pip install -Uq git+https://github.com/fastai/fastcore.git\n    pip install -Uq git+https://github.com/fastai/execnb.git\n    pip install -U git+https://github.com/fastai/nbdev.git\n    wget -q $(curl https://latest.fast.ai/pre/quarto-dev/quarto-cli/linux-amd64.deb)\n    sudo dpkg -i quarto*.deb\n    pip install -Uq matplotlib\n    pip install -Uq setuptools\n    pip install -Uq scikit-learn\n    pip install -Uq shapely\n    nbdev_docs\nPongamos especial atenci√≥n en las √∫ltimas lineas, aqu√≠ instalamos las dependencias que se utilizaron en hacer nuestra libreria y son necesarias para que los notebooks que hicimos puedan correr. Una vez instaladas las dependencias podemos generar la documentaci√≥n con ‚Äònbdev_docs‚Äô.\nComo en la maquina virtual ya generamos nuestra documentaci√≥n ahora vamos a ponerla dentro de un nuevo ‚Äòbranch‚Äô, por eso le tenemos que dar permiso para escribir, dentro del repositorio y usar ese ‚Äòbranch‚Äô para publicar la documentaci√≥n usando el siguiente paso:\n- name: Deploy to GitHub Pages\n    uses: peaceiris/actions-gh-pages@v4\n    with:\n      github_token: ${{ secrets.GITHUB_TOKEN }}\n      force_orphan: true\n      publish_dir: ./_docs\n      # The following lines assign commit authorship to the official GH-Actions bot for deploys to `gh-pages` branch.\n      # You can swap them out with your own user credentials.\n      user_name: github-actions[bot]\n      user_email: 41898282+github-actions[bot]@users.noreply.github.com\nEsto usa las acciones descritas en peaceiris/actions-gh-pages@v4 las cuales ya estan automatizadas para generar un nuevo branch con nombre ‚Äògh-pages‚Äô y a√±adir el contenido de la documentaci√≥n dentro de el branch. Lo que se a√±ade dentro del branch es lo que se encuentra dentro del directorio ‚Äô./_docs‚Äô. ‚Äògithub_token‚Äô nos permite autenticar el trabajo realizado por el flujo de trabajo. Los parametros de ‚Äòuser_name‚Äô y ‚Äòuser_email‚Äô permiten avisar que acciones fueron realizadas por el script ‚Äòpeaceiris/actions-gh-pages@v4‚Äô y tendran como las cuales apareceran que fueron realizadas por github-pages bot . Estas acciones nos enviaran un mail con el resultado del trabajo realizado , es decir si este fue exitoso o no.\n\n\nArchivo test.yaml\nEn el caso de las pruebas estas se hacen en las acciones en el archivo ‚Äòtest.yaml‚Äô y vamos a remplazar su contenido por el c√≥digo siguiente:\n\nname: Test CI\non:  [workflow_dispatch, pull_request, push]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n      - name: Install Nbdev Dependencies\n        shell: bash\n        run: |\n          python -m pip install --upgrade pip\n          pip install -Uq git+https://github.com/fastai/ghapi.git # you need this for enabling pages\n          pip install -Uq git+https://github.com/fastai/fastcore.git\n          pip install -Uq git+https://github.com/fastai/execnb.git\n          pip install -U git+https://github.com/fastai/nbdev.git\n      - name: Install package dependencies\n        shell: bash\n        run: |\n          python -m pip install -Uq matplotlib\n          python -m pip install -Uq setuptools\n          python -m pip install -Uq scikit-learn\n          python -m pip install -Uq shapely\n\n      - name: Test the package\n        shell: bash\n        run: |\n          echo \"Check we are starting with clean git checkout\"\n          if [[ `git status --porcelain -uno` ]]; then\n            git diff\n            echo \"git status is not clean\"\n            false\n          fi\n          echo \"Trying to strip out notebooks\"\n          nbdev_clean\n          echo \"Check that strip out was unnecessary\"\n          git status -s # display the status to see which nbs need cleaning up\n          if [[ `git status --porcelain -uno` ]]; then\n            git status -uno\n            echo -e \"!!! Detected unstripped out notebooks\\n!!!Remember to run nbdev_install_hooks\"\n            echo -e \"This error can also happen if you are using an older version of nbdev relative to what is in CI.  Please try to upgrade nbdev with the command `pip install -U nbdev`\"\n            false\n          fi\n          nbdev_export\n          if [[ `git status --porcelain -uno` ]]; then\n            echo \"::error::Notebooks and library are not in sync.  Please run nbdev_export.\"\n            git status -uno\n            git diff\n            exit 1;\n          fi\n          if [ ! $SKIP_TEST ]; then\n            nbdev_test --flags \"$FLAGS\"\n          fi\n      \nDe forma similar el nombre del trabajo es ‚ÄòTest CI‚Äô los trabajos se realizaran cuando cuando se hace una petici√≥n de forma manual o se hace un pull o un push.\nSe corre en una maquina virtual con ubuntu ‚Äòruns-on: ubuntu-latest‚Äô y hace un check out, se instala python y nbdev junto con sus dependencias.\nEn el siguiente paso se instalan las dependencias de la librer√≠a en la maquina virtual.\n- name: Install package dependencies\n    shell: bash\n    run: |\n        python -m pip install -Uq matplotlib\n        python -m pip install -Uq setuptools\n        python -m pip install -Uq scikit-learn\n        python -m pip install -Uq shapely\n    \nY en lo que resta del c√≥digo verifica ciestas cosas y hace las pruebas usando nbdev_test dentro de la maquina virtual\n\ngit se verifica ell contenido de la version del repositrio que se encuentra en la maquina virtual\nVerifica que los notebooks no tengan cosas inecesarias, si no es asi marca error\nConstruye la librer√≠a dentro de la maquina virtual usando ‚Äònbdev_export‚Äô\nHace las pruebas usando ‚Äònbdev_test‚Äô\n\nname: Test the package\n    shell: bash\n    run: |\n        echo \"Check we are starting with clean git checkout\"\n        if [[ `git status --porcelain -uno` ]]; then\n        git diff\n        echo \"git status is not clean\"\n        false\n        fi\n        echo \"Trying to strip out notebooks\"\n        nbdev_clean\n        echo \"Check that strip out was unnecessary\"\n        git status -s # display the status to see which nbs need cleaning up\n        if [[ `git status --porcelain -uno` ]]; then\n        git status -uno\n        echo -e \"!!! Detected unstripped out notebooks\\n!!!Remember to run nbdev_install_hooks\"\n        echo -e \"This error can also happen if you are using an older version of nbdev relative to what is in CI.  Please try to upgrade nbdev with the command `pip install -U nbdev`\"\n        false\n        fi\n        nbdev_export\n        if [[ `git status --porcelain -uno` ]]; then\n        echo \"::error::Notebooks and library are not in sync.  Please run nbdev_export.\"\n        git status -uno\n        git diff\n        exit 1;\n        fi\n        if [ ! $SKIP_TEST ]; then\n        nbdev_test --flags \"$FLAGS\"\n        fi\nComo se observa, los pasos anteriores son los que ya hemos desde la instalaci√≥n y la construcci√≥n de la librer√≠a.\nSi todo se encuentra en orden podemos salvar los archivos, hacer un commit, y hacer un push. Como las acciones se ejecuntan cuando se hace un push podemos ver en las acciones de github e ir a la p√°gina de github para verificar que el flujo de trabajo funciona de forma adecuada. En el menu Actions del repositrio.\n\n\n\nFigure¬†6: Menu github actions\n\n\nEn este menu veremos las aciones que se llevan del lado izquierdoo acabo en nuestro caso:\n\nDeploy to Github Pages\nTest CI\npages-build-deployment (ejecutado al hacer el branch ‚Äògh-pages‚Äô)\n\nEn el centro una lista con los commits realizado y el resultado de las acciones que se llevaron acabo y si estas tuvieron exito (‚úÖ) o no (‚ùå).\n\n\n\nFigure¬†7: Woorkflows Actions\n\n\nPara habilitar nuestra pagina de documentaci√≥n se tienen que seguir los mismos pasoes que vimos anteriormente y se selecciona el branch de ‚Äògh-pages‚Äô para habilitar la documentaci√≥n."
  }
]